# Медленные потребители

Для устойчивости и высокой доступности NATS предоставляет встроенные механизмы, автоматически «подрезающие» зарегистрированный граф интереса подписчиков, включая медленных потребителей и ленивых слушателей. NATS автоматически обрабатывает медленного потребителя. Если клиент не обрабатывает сообщения достаточно быстро, сервер NATS отключает его. Для масштабирования NATS обеспечивает авто‑прореживание клиентских соединений. Если подписчик не отвечает на ping‑запросы сервера в пределах [ping‑pong интервала](../../reference/nats-protocol/nats-protocol/#PINGPONG), клиент отключается. Клиент должен иметь логику переподключения к серверу.

В core NATS потребители, которые не успевают, обрабатываются иначе, чем во многих других системах сообщений: NATS предпочитает защищать систему в целом, а не подстраиваться под конкретного потребителя ради гарантии доставки.

**Что такое медленный потребитель?**

Медленный потребитель — это подписчик, который не успевает за потоком сообщений, доставляемых сервером NATS. Это распространенный случай в распределенных системах, потому что генерировать данные часто проще, чем обрабатывать. Когда потребители не успевают, на остальную систему возникает back pressure. У NATS есть механизмы для уменьшения этого давления.

NATS выявляет медленных потребителей на стороне клиента или сервера и уведомляет через зарегистрированные callbacks, сообщения в логах и статистику в мониторинговых endpoint сервера.

**Что происходит с медленными потребителями?**

Когда это обнаруживается на стороне клиента, приложение уведомляется, а сообщения отбрасываются, чтобы потребитель мог продолжить работу и снизить потенциальное давление. Когда это обнаруживается на стороне сервера, сервер отключает соединение с медленным потребителем, защищая себя и целостность системы сообщений.

## Медленные потребители, выявленные на стороне клиента

[Клиент может определить, что он медленный потребитель](../../using-nats/developing-with-nats/events/slow.md#detect-a-slow-consumer-and-check-for-dropped-messages) на локальном соединении и уведомить приложение через асинхронный callback ошибок. Лучше поймать медленного потребителя локально на клиенте, чем позволить серверу обнаружить это состояние. Этот пример показывает, как определить и зарегистрировать асинхронный обработчик ошибок, который будет обрабатывать ошибки медленного потребителя.

```go
func natsErrHandler(nc *nats.Conn, sub *nats.Subscription, natsErr error) {
    fmt.Printf("error: %v\n", natsErr)
    if natsErr == nats.ErrSlowConsumer {
        pendingMsgs, _, err := sub.Pending()
        if err != nil {
            fmt.Printf("couldn't get pending messages: %v", err)
            return
        }
        fmt.Printf("Falling behind with %d pending messages on subject %q.\n",
            pendingMsgs, sub.Subject)
        // Log error, notify operations...
    }
    // check for other errors
}

// Set the error handler when creating a connection.
nc, err := nats.Connect("nats://localhost:4222",
  nats.ErrorHandler(natsErrHandler))
```

При таком коде и настройках по умолчанию ошибка медленного потребителя даст вывод примерно такого вида:

```
error: nats: slow consumer, messages dropped
Falling behind with 65536 pending messages on subject "foo".
```

Обратите внимание: если вы используете синхронного подписчика, `Subscription.NextMsg(timeout time.Duration)` тоже вернет ошибку, указывающую на медленного потребителя и сброшенные сообщения.

## Медленные потребители, выявленные сервером

Если клиент не обрабатывает сообщения достаточно быстро, сервер буферизует сообщения в исходящем соединении к клиенту. Когда сервер не может записывать данные клиенту достаточно быстро, он, чтобы защитить себя, помечает подписчика как «медленного потребителя» и может разорвать соответствующее соединение.

Когда сервер инициирует ошибку медленного потребителя, в его выводе будет следующее:

```
[54083] 2017/09/28 14:45:18.001357 [INF] ::1:63283 - cid:7 - Slow Consumer Detected
```

Сервер также ведет счетчик ошибок медленного потребителя, доступный через мониторинговый endpoint `varz` в поле `slow_consumers`.

## Обработка медленных потребителей

Помимо использования [JetStream](../../nats-concepts/jetstream/) или оптимизации приложения‑потребителя, доступны несколько вариантов: масштабировать, ограничивать или настраивать NATS под вашу среду.

**Масштабирование через подписчиков очередей**

Идеально, если вы не полагаетесь на порядок сообщений. Убедитесь, что подписка NATS входит в [queue group](../../nats-concepts/core-nats/queue-groups/queue.md), затем масштабируйтесь, создавая больше экземпляров сервиса или приложения. Это отличный подход для микросервисов — каждый экземпляр будет получать часть сообщений для обработки, и вы просто добавляете экземпляры сервиса для масштабирования. Никаких изменений кода, конфигурации или простоя.

**Создание масштабируемого пространства имен subject**

Можно дальше распределить работу через пространство имен subject, заранее продумав дизайн. Это полезно, если нужно сохранить порядок сообщений. Общая идея — публиковать в глубокое пространство имен subject и потреблять через wildcard‑подписки, оставляя себе запас для расширения и распределения работы в будущем.

Например, если сервис получает телеметрию от IoT‑устройств, расположенных по городу, можно публиковать в namespace `Sensors.North`, `Sensors.South`, `Sensors.East`, `Sensors.West`. Изначально вы подписываетесь на `Sensors.>`, чтобы обрабатывать все в одном потребителе. По мере роста и превышения скорости данных возможности одного потребителя можно заменить его четырьмя приложениями‑потребителями, подписанными на каждый subject, представляющий меньший сегмент данных. При этом приложения‑публикаторы остаются без изменений.

**Ограничение (meter) издателя**

Менее желательный вариант — ограничивать издателя. Есть несколько способов: от простого замедления издателя до более сложного подхода с периодическим блокирующим запрос‑ответом, чтобы подстроиться под скорость подписчиков.

**Настройка NATS через конфигурацию**

Сервер NATS можно настроить, чтобы определить, сколько данных может быть буферизовано до признания потребителя медленным, и некоторые официально поддерживаемые клиенты позволяют настраивать размеры буферов. Уменьшение буферов позволит быстрее выявлять медленных потребителей. Увеличение буферов обычно не рекомендуется, если только вы не обрабатываете временные всплески данных. Часто увеличение буферной емкости лишь _откладывает_ проблемы медленных потребителей.

### Конфигурация сервера

У NATS server есть дедлайн записи, который он использует при записи в соединение. Когда этот дедлайн превышен, клиент считается медленным потребителем. Если вы сталкиваетесь с ошибками медленных потребителей на сервере, можно увеличить дедлайн записи, чтобы буферизовать больше данных.

Опция `write_deadline` в конфигурационном файле сервера позволяет это настроить:

```
write_deadline: 2s
```

Настройка этого параметра уместна, когда нужно принять всплески данных. _**Убедитесь, что вы не просто откладываете ошибку медленного потребителя.**_

### Конфигурация клиента

Большинство официально поддерживаемых клиентов имеют внутренний буфер ожидающих сообщений и уведомляют приложение через асинхронный callback ошибок, если локальная подписка не успевает. Получение ошибки локально не обязательно означает, что сервер уже идентифицировал подписку как медленного потребителя.

Этот буфер можно настроить, установив лимиты pending после создания подписки:

```go
if err := sub.SetPendingLimits(1024*500, 1024*5000); err != nil {
  log.Fatalf("Unable to set pending limits: %v", err)
}
```

Лимит pending‑сообщений подписчика по умолчанию — `65536`, а лимит pending‑байт по умолчанию — `65536*1024`.

Если клиент достигает этого внутреннего лимита, он будет отбрасывать сообщения и продолжать обрабатывать новые. Это соответствует доставке NATS «at most once». Приложение само должно обнаруживать пропущенные сообщения и восстанавливаться после этого состояния.
