# Маппинг subject и формирование трафика

_Поддерживается начиная с NATS Server версии 2.2_

Subject mapping — очень мощная возможность сервера NATS, полезная для канареечных развертываний, A/B‑тестирования, chaos‑тестирования и миграции на новое пространство имен subject.

## Настройка subject mapping

Маппинги subject определяются и применяются на уровне аккаунта. Если вы используете статическую безопасность аккаунтов, вам нужно редактировать конфигурационный файл сервера. Если же используется JWT‑безопасность (Operator Mode), то нужно использовать `nsc` или пользовательские инструменты для изменения и отправки изменений в ваш аккаунт.

Примечание: _Вы также можете использовать subject mapping как часть определения импортов и экспортов между аккаунтами._

### Статическая аутентификация

В любом из статических режимов аутентификации маппинги задаются в конфигурационном файле сервера. Любые изменения в маппингах вступят в силу сразу после отправки серверу сигнала перезагрузки (например, `nats-server --signal reload`).

Блок `mappings` может находиться на верхнем уровне (применяется к глобальному аккаунту) или быть ограничен конкретным аккаунтом.

```text
mappings = {

  # Простой прямой маппинг. Сообщения, опубликованные в foo, маппятся в bar.
  foo: bar

  # Перемаппинг токенов можно делать с помощью $<N>, где N — позиция токена.
  # В этом примере bar.a.b будет отображаться в baz.b.a.
  bar.*.*: baz.$2.$1

  # Можно ограничить маппинг конкретным кластером
  foo.cluster.scoped : [
    { destination: bar.cluster.scoped, weight:100%, cluster: us-west-1 }
  ]

  # Взвешенный маппинг для канареечного или A/B‑тестирования.
  # Можно динамически менять в любой момент через reload сервера.
  myservice.request: [
    { destination: myservice.request.v1, weight: 90% },
    { destination: myservice.request.v2, weight: 10% }
  ]

  # Пример тестирования wildcard‑маппинга, сбалансированного по двум subject.
  # 20% трафика маппится в сервис в QA, который намеренно падает.
  myservice.test.*: [
    { destination: myservice.test.$1, weight: 80% },
    { destination: myservice.test.fail.$1, weight: 20% }
  ]

  # Прием chaos‑тестирования: вводим 50% искусственной потери сообщений,
  # опубликованных в foo.loss
  foo.loss.>: [ { destination: foo.loss.>, weight: 50% } ]
}
```

### JWT‑аутентификация

При использовании JWT‑аутентификации маппинги задаются в JWT аккаунта. JWT аккаунтов можно создавать или менять через [_JWT API_](https://github.com/nats-io/jwt) или через CLI `nsc`. Подробности см. `nsc add mapping --help`, `nsc delete mapping --help`. Изменения маппинга вступают в силу сразу после того, как измененный JWT аккаунта отправлен на серверы NATS (то есть `nsc push`).

Примеры использования `nsc` для управления маппингами:

* Добавить новый маппинг: `nsc add mapping --from "a" --to "b"`
* Изменить запись, например задать вес: `nsc add mapping --from "a" --to "b" --weight 50`
* Добавить две записи с одного subject, задать веса и выполнить несколько раз: `nsc add mapping --from "a" --to "c" --weight 50`
* Удалить маппинг: `nsc delete mapping --from "a"`

## Простой маппинг

Пример `foo:bar` прямолинейный. Все сообщения, которые сервер получает на subject `foo`, перемаппируются и могут быть получены клиентами, подписанными на `bar`.

## Переупорядочивание токенов subject

Wildcard‑токены можно ссылочно использовать через `$<позиция>`. Например, первый wildcard‑токен — это $1, второй — $2 и т. д. Ссылки на эти токены позволяют переупорядочивать части subject.

При таком маппинге:

```text
  bar.*.*: baz.$2.$1
```

Сообщения, опубликованные в `bar.a.b`, будут перемаппированы сервером в `baz.b.a`. Сообщения на `bar.one.two` будут перемаппированы в `baz.two.one` и т. д.

## Взвешенные маппинги для A/B‑тестирования или канареечных релизов

Трафик можно разделять по процентам с одного subject на несколько subject. Ниже пример для канареечного развертывания, начиная с версии 1 вашего сервиса.

Приложения будут отправлять запросы сервису на `myservice.requests`. Обработчики сервиса будут подписываться на `myservice.requests.v1`. Конфигурация будет такой:

```text
  myservice.requests: [
    { destination: myservice.requests.v1, weight: 100% }
  ]
```

Все запросы на `myservice.requests` попадут в версию 1 сервиса.

Когда выходит версия 2, вы хотите протестировать ее канареечно. Версия 2 подписывается на `myservice.requests.v2`. Запустите экземпляры сервиса (не забывайте про queue‑подписчиков и балансировку нагрузки).

Обновите конфигурационный файл так, чтобы часть запросов, отправляемых на `myservice.requests`, перенаправлялась в версию 2. В данном случае используем 2%.

```text
  myservice.requests: [
    { destination: myservice.requests.v1, weight: 98% },
    { destination: myservice.requests.v2, weight: 2% }
  ]
```

В этот момент вы можете [перезагрузить](../nats_admin/signals.md) сервер, чтобы применить изменения без простоя. После перезагрузки 2% запросов будут обслуживаться новой версией.

После того как вы убедились в стабильности версии 2, переключите 100% трафика и перезагрузите сервер с новой конфигурацией.

```text
  myservice.requests: [
    { destination: myservice.requests.v2, weight: 100% }
  ]
```

Теперь остановите экземпляры версии 1.

## Формирование трафика в тестировании

Формирование трафика полезно в тестировании. У вас может быть сервис в QA, который симулирует сценарии отказов и должен получать 20% трафика запросов для тестирования отправителя.

```text
  myservice.requests.*: [
    { destination: myservice.requests.$1, weight: 80% },
    { destination: myservice.requests.fail.$1, weight: 20% }
  ]
```

## Искусственные потери

В качестве альтернативы можно вводить потери в систему для chaos‑тестирования, маппируя процент трафика на тот же subject. В этом радикальном примере 50% трафика, опубликованного в `foo.loss.a`, будет искусственно отброшено сервером.

```text
  foo.loss.>: [ { destination: foo.loss.>, weight: 50% } ]
```

Можно одновременно разделять трафик и вводить потери для тестирования. Здесь 90% запросов пойдут в ваш сервис, 8% — в сервис, который имитирует отказ, а оставшиеся 2% будут симулировать потерю сообщений.

```text
  myservice.requests: [
    { destination: myservice.requests.v3, weight: 90% },
    { destination: myservice.requests.v3.fail, weight: 8% }
    # оставшиеся 2% «теряются»
  ]
```
