# Конфигурация

Хотя у сервера NATS есть множество флагов для простого тестирования возможностей из командной строки, стандартный способ настройки продукта NATS — через конфигурационный файл.
Мы используем простой формат конфигурации, который объединяет лучшее из традиционных форматов и более новых стилей, таких как JSON и YAML.

```shell
nats-server -config my-server.conf
```

Конфигурация NATS поддерживает следующий синтаксис:

- Строки могут быть закомментированы `#` и `//`
- Значения могут быть присвоены свойствам с помощью разделителей:
  - Знак равенства: `foo = 2`
  - Двоеточие: `foo: 2`
  - Пробел: `foo 2`
- Массивы заключаются в квадратные скобки: `["a", "b", "c"]`
- Map‑объекты заключаются в фигурные скобки: `{foo: 2}`
- Map‑объекты могут быть назначены без разделителя: `accounts { SYS {...}, cloud-user {...} }`  
- Точки с запятой могут использоваться как необязательные терминаторы: `host: 127.0.0.1; port: 4222;`

Конфигурационный файл NATS парсится в кодировке UTF‑8.

{% hint style="info" %}
Мы настоятельно рекомендуем использовать только ASCII для имен и значений, ограничивая использование Unicode; не‑ASCII текст оставляйте для комментариев.
{% endhint %}

#### Примечание

Конфигурация NATS в файле может быть также представлена как JSON‑объект (с комментариями!), но для использования переменных они должны оставаться без кавычек.

{% hint style="info" %}
JSON‑конфиги следует ограничивать машинно‑сгенерированными конфигурационными файлами.
{% endhint %}

## Строки и числа

Парсер конфигурации очень терпим, как вы уже видели:

- значения могут быть примитивом, списком или map‑объектом
- строки и числа обычно «делают правильное»
- числа поддерживают единицы, например 1K для 1000 и 1KB для 1024

Строковые значения, начинающиеся с цифры, _могут_ создавать проблемы. Чтобы принудительно интерпретировать такие значения как строки, заключите их в кавычки.

_Плохая конфигурация_:

```text
listen: 127.0.0.1:4222
authorization: {
    # Плохо — ошибка парсинга числа
    token: 3secret
}
```

Исправленная конфигурация:

```text
listen: 127.0.0.1:4222
authorization: {
    # Хорошо
    token: "3secret"
}
```

## Переменные

Конфигурации сервера могут задавать переменные. Переменные позволяют ссылаться на значение из одного или нескольких разделов конфигурации.



**Синтаксис переменных:**

* Имеют область видимости блока
* На переменные ссылаются с префиксом `$`. Переменные в кавычках игнорируются. Например, `foo = "$VAR1"` приведет к тому, что `foo` станет строкой `"$VAR1"`.
* Переменные ДОЛЖНЫ быть использованы, чтобы распознаваться как переменные. Парсер отличает `unknown field` от переменной, находя ссылку на переменную.
* Ссылки на переменные, которые не определены, будут разрешаться из переменных окружения.

**Последовательность разрешения переменной:**
* Ищем переменную в текущей области видимости
* Ищем переменную в родительских областях
* Ищем переменную в переменных окружения
* Если не найдена — останавливаем запуск сервера с ошибкой ниже

`nats-server: variable reference for 'PORT' on line 5 can not be found`

{% hint style="warning" %}
Если значение переменной окружения начинается с цифры, могут возникать проблемы с разрешением в зависимости от версии сервера.
{% endhint %}


```text
# Определяем переменную в конфиге
TOKEN: "secret"

# Ссылаемся на переменную
authorization {
    token: $TOKEN
}
```

```text
# Определяем переменную в конфиге
# Но TOKEN никогда не используется, что приводит к ошибке парсинга
TOKEN: "secret"

# Ссылаемся на переменную
authorization {
    token: "another secret"
}
```
```shell
unknown field "TOKEN"
```

Похожая конфигурация, но теперь переменная разрешается из окружения:
```shell
export TOKEN="hello"
nats-server -c /config/file
```

```text
# TOKEN определена в окружении
authorization {
    token: $TOKEN
}
```



## Директива include

Директива `include` позволяет разбивать конфигурацию сервера на несколько файлов. Это полезно, чтобы разделить конфигурацию на части, которые можно легко переиспользовать между разными серверами.

`include` _должна_ использовать относительные пути, и они задаются относительно основного конфигурационного файла (указанного через опцию `-c`):

server.conf:

```text
listen: 127.0.0.1:4222
include ./auth.conf
```

> Обратите внимание, `include` не сопровождается `=` или `:`, так как это _директива_.

auth.conf:

```text
authorization: {
    token: "f0oBar"
}
```

```text
> nats-server -c server.conf
```

## Перезагрузка конфигурации

Файл конфигурации читается сервером при запуске и далее не пересканируется и не блокируется.

Сервер может перезагрузить большинство изменений конфигурации без перезапуска и без отключения клиентов, отправив nats-server [сигнал](/running-a-nats-service/nats_admin/signals.md):

```shell
nats-server --signal reload
```

Начиная с NATS v2.10.0, сигнал перезагрузки можно отправить через сервис NATS с использованием пользователя системного аккаунта, где `<server-id>` — уникальный ID целевого сервера.

```shell
nats --user sys --password sys request '$SYS.REQ.SERVER.<server-id>.RELOAD' ""
```


## Свойства конфигурации

Конфигурационные файлы имеют следующую структуру (без определенного порядка). Все блоки и свойства опциональны (кроме host и port).

См. разделы ниже со ссылками на подробные описания каждого блока конфигурации.

```text
# Общие настройки
host: 0.0.0.0
port: 4222

# Различные опции уровня сервера
# ...

# Следующие разделы — карты с набором (вложенных) свойств

jetstream {
    # Расположение хранилища JetStream, лимиты и шифрование
	store_dir: nats
}

tls { 
    # Конфигурационная карта параметров tls, используемых для клиентских
    # соединений, маршрутов и https‑мониторинга.
}
```
