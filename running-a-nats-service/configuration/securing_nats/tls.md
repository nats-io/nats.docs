# Включение TLS

Сервер NATS использует современные семантики TLS для шифрования клиентских, маршрутных и мониторинговых соединений. [Проверьте здесь подводные камни.](#problems-with-self-signed-certificates) 

Конфигурация сервера строится вокруг карты `tls`, которая имеет следующие свойства:

| Свойство | Описание |  |  |
| :--- | :--- | :--- | :--- |
| `cert_file` | Файл TLS‑сертификата. |  |  |
| `key_file` | Файл ключа TLS‑сертификата. |  |  |
| `ca_file` | Файл [центра сертификации](tls.md#certificate-authorities) TLS. Если отсутствует, используется системное хранилище доверия. |  |  |
| `cipher_suites` | Если задано, разрешены только указанные TLS cipher suites. Значения должны соответствовать версии golang, использованной для сборки сервера. |  |  |
| `curve_preferences` | Список TLS‑кривых шифрования в порядке использования. |  |  |
| `insecure` | Пропускать проверку сертификата. Применяется только к исходящим соединениям, НЕ к входящим клиентским. **НЕ рекомендуется** |  |  |
| `min_version` | Минимальная версия TLS. По умолчанию `"1.2"`. |  |  |
| `timeout` | [Таймаут](tls.md#tls-timeout) TLS‑рукопожатия в дробных секундах. По умолчанию `2` секунды. |  |  |
| `verify` | Если `true`, требовать и [проверять](auth_intro/tls_mutual_auth.md#validating-a-client-certificate) клиентские сертификаты. Чтобы поддержать использование браузером, эта опция не применяется к мониторингу. |  |  |
| `verify_and_map` | Если `true`, требовать и проверять клиентские сертификаты и [маппить](auth_intro/tls_mutual_auth.md#mapping-client-certificates-to-a-user) значения сертификата для аутентификации. Также не применяется к мониторингу. |  |  |
| `verify_cert_and_check_known_urls` | Настраивается только в контексте не‑клиентских подключений, где `verify: true` по умолчанию ([cluster](../clustering/)/[gateway](../gateways/)). `DNS`‑записи `X509v3 Subject Alternative Name` входящего сертификата будут сопоставлены со всеми URL в контексте конфигурации, где находится эта `tls`‑карта. Если найдено совпадение, соединение принимается, иначе отклоняется. Для gateways мы сопоставляем все DNS‑записи сертификата со всеми gateway URL. Для кластера — со всеми route URL. В результате динамический рост кластера может потребовать изменений конфигурации в других кластерах, где этот флаг `true`. Проверка DNS‑имен выполняется по [rfc6125](https://tools.ietf.org/html/rfc6125#section-6.4.1). Поддерживается только полный wildcard `*` для самого левого лейбла. Это один из способов сохранить гибкость роста кластера. |  |  |
| `pinned_certs` | Список hex‑кодированных SHA256 отпечатков публичного ключа в DER. При наличии во время TLS‑рукопожатия отпечаток предъявленного сертификата должен быть в списке, иначе соединение закрывается. Последовательность команд для получения записи: `openssl x509 -noout -pubkey -in <cert> | openssl pkey -pubin -outform DER | openssl dgst -sha256`. |

Самая простая конфигурация:

```text
tls: {
  cert_file: "./server-cert.pem"
  key_file: "./server-key.pem"
}
```

Или с помощью [опций сервера](../../running/flags.md#tls-options):

```shell
nats-server --tls --tlscert=./server-cert.pem --tlskey=./server-key.pem
```
```text
[21417] 2019/05/16 11:21:19.801539 [INF] Starting nats-server version 2.0.0
[21417] 2019/05/16 11:21:19.801621 [INF] Git commit [not set]
[21417] 2019/05/16 11:21:19.801777 [INF] Listening for client connections on 0.0.0.0:4222
[21417] 2019/05/16 11:21:19.801782 [INF] TLS required for client connections
[21417] 2019/05/16 11:21:19.801785 [INF] Server id is ND6ZZDQQDGKYQGDD6QN2Y26YEGLTH6BMMOJZ2XJB2VASPVII3XD6RFOQ
[21417] 2019/05/16 11:21:19.801787 [INF] Server is ready
```

Обратите внимание: лог показывает, что клиентские соединения обязаны использовать TLS. Если запустить сервер в Debug‑режиме с `-D` или `-DV`, логи покажут выбор cipher suite для каждого подключенного клиента:

```text
[22242] 2019/05/16 11:22:20.216322 [DBG] 127.0.0.1:51383 - cid:1 - Client connection created
[22242] 2019/05/16 11:22:20.216539 [DBG] 127.0.0.1:51383 - cid:1 - Starting TLS client connection handshake
[22242] 2019/05/16 11:22:20.367275 [DBG] 127.0.0.1:51383 - cid:1 - TLS handshake complete
[22242] 2019/05/16 11:22:20.367291 [DBG] 127.0.0.1:51383 - cid:1 - TLS version 1.2, cipher suite TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
```

Когда секция `tls` задана на корне конфигурации, она также влияет на порт мониторинга, если задана опция `https_port`. Другие секции, такие как `cluster`, могут задавать свой `tls` блок.

## TLS‑first Handshake

_Начиная с NATS v2.10.4_

Клиентские подключения следуют модели, при которой при создании TCP‑соединения сервер немедленно отправляет [INFO‑сообщение протокола](../../../reference/nats-protocol/nats-protocol/README.md#info) в открытом виде. Это INFO‑сообщение содержит метаданные, включая требование защищенного соединения.

Некоторые среды предпочитают, чтобы TLS‑соединение клиентов инициировалось сразу, то есть без передачи трафика в открытом виде. Ранее это можно было обойти через websocket‑подключение. Однако если websocket не желателен, сервер можно настроить на выполнение TLS‑рукопожатия до отправки INFO‑сообщения протокола.

Подключиться смогут только клиенты, которые реализуют эквивалентную опцию.

Конфигурация будет выглядеть примерно так:

```text
tls: {
  cert_file: "./server-cert.pem"
  key_file: "./server-key.pem"
  handshake_first: true
}
```

Однако параметр можно установить в `auto` или в [Golang time duration](https://pkg.go.dev/time#ParseDuration) (например `250ms`), чтобы откатиться к исходному поведению. Это рассчитано на развертывания, где известно, что не все клиенты обновлены до библиотек с поддержкой TLS‑first handshake.

После истечения задержки без TLS‑рукопожатия от клиента сервер возвращается к отправке INFO‑сообщения, чтобы старые клиенты могли подключиться. Клиенты, которые подключаются с опцией "TLS first", будут помечены в результатах мониторинга `Connz`. Это позволит администратору отслеживать приложения, которые еще требуют обновления.

Конфигурация будет такой:

```text
tls: {
  cert_file: "./server-cert.pem"
  key_file: "./server-key.pem"
  handshake_first: auto
}
```

При таком значении задержка отката по умолчанию — 50 миллисекунд.

Длительность можно задать явно, например 300 миллисекунд:

```text
tls {
    cert_file: ...
    key_file: ...

    handshake_first: "300ms"
}
```

Понимайте, что любая конфигурация, отличная от `true`, приводит к тому, что сервер отправит INFO‑сообщение после истечения времени без TLS‑рукопожатия со стороны клиента. Поэтому, если администраторы не хотят передачи данных в открытом виде, значение должно быть только `true`. Это потребует обновления приложений до библиотек, поддерживающих эту опцию, что может быть не всегда доступно.

<a id="tls-timeout"></a>
## Таймаут TLS

Настройка `timeout` позволяет управлять временем, которое дается клиенту на апгрейд соединения до TLS. Если клиенты отключаются во время TLS‑рукопожатия, стоит увеличить значение. Однако имейте в виду: большой `timeout` делает сервер уязвимым к атакам, где клиент не переходит на TLS и потребляет ресурсы. С другой стороны, если слишком уменьшить TLS‑`timeout`, вы вероятно увидите ошибки рукопожатия.

```text
tls: {
  cert_file: "./server-cert.pem"
  key_file: "./server-key.pem"
  # клиенты не смогут подключиться (значение слишком низкое)
  timeout: 0.0001
}
```

<a id="certificate-authorities"></a>
## Центры сертификации

Файл `ca_file` должен содержать один или несколько CA в формате PEM, в виде bundle. Это распространенный формат.

Когда сертификат выпускается, он часто сопровождается копией intermediate‑сертификата, использованного для выпуска. Это полезно для валидации этого сертификата, но не обязательно хороший выбор в качестве единственного CA для проверки других сертификатов, которые может видеть сервер.

Стоит учитывать, что организации‑эмитенты сертификатов меняют используемые intermediate. Например, CA может выпускать intermediate парами — активный и резервный — и иметь право переключаться на резервный без уведомления. Вы, скорее всего, захотите доверять _обоим_ для директивы `ca_file`, чтобы подготовиться к такому дню, а после компрометации первого CA — удалить его. Так переход от одного CA к другому не сломает развертывание NATS.

<a id="self-signed-certificates-for-testing"></a>
## Самоподписанные сертификаты для тестирования

Объяснение [публичной инфраструктуры ключей](https://en.wikipedia.org/wiki/Public_key_infrastructure), [центров сертификации (CA)](https://en.wikipedia.org/wiki/Certificate_authority) и [x509](https://tools.ietf.org/html/rfc5280) [сертификатов](https://en.wikipedia.org/wiki/Public_key_certificate) выходит за рамки этого документа. Также как и объяснение, как получить корректно доверенные сертификаты.

Если к вам должны подключаться внешние по отношению к организации пользователи — получайте сертификаты у публичного CA. При выборе CA внимательно подумайте о ревокации, сроках ротации и автоматизации. Если подключаться должны произвольные приложения внутри вашей организации — используйте сертификат от внутреннего CA. Если подключаться должны только ресурсы внутри конкретной среды, у нее может быть собственный автоматический CA (например, в Kubernetes‑кластерах) — используйте его.

**Только** для **тестирования** имеет смысл генерировать самоподписанные сертификаты, включая собственный CA. Ниже — **краткое** руководство, как это сделать и на что обратить внимание.

> **НЕ ИСПОЛЬЗУЙТЕ эти сертификаты в продакшне!!!**

<a id="problems-with-self-signed-certificates"></a>
### Проблемы с самоподписанными сертификатами

Проблемы и подводные камни здесь не ограничиваются самоподписанными сертификатами. Скорее всего, вы столкнетесь с ними в DEV‑окружениях при использовании таких сертификатов.

#### Client advertise не совпадает с TLS‑именами

Кластер NATS объявляет `host:port` всех узлов кластера подключающемуся клиенту. При подключении по TLS имя сервера (или IP) проверяется по сертификату, представленному сервером.

При использовании TLS важно контролировать hostname, который клиенты будут использовать при обнаружении сервера. По умолчанию кластер объявляет IP‑адрес, что может привести к ошибке проверки TLS hostname из‑за IP SANs.

Задайте `advertise` или `cluster_advertise` в разделе cluster, чтобы объявлять проверяемые имена серверов. См. [cluster_config.md](../clustering/cluster_config.md)

#### Отсутствие в нужных хранилищах доверия

Как и должно быть, такие сертификаты **не доверены** системой, на которой работают ваш сервер или клиенты.

Один вариант — указать CA в каждом клиенте, который вы используете. Если вы используете `verify`, `verify_and_map` или `verify_cert_and_check_known_urls`, нужно указать `ca_file` на сервере. Если у вас более сложная конфигурация с cluster, gateways или leaf nodes, `ca_file` должен присутствовать в `tls`‑картах, используемых для подключения к серверу с самоподписанными сертификатами. Это работает для серверов и библиотек из экосистемы NATS, но вы столкнетесь с проблемами при подключении другими инструментами, например браузером.

Другой вариант — настроить системное хранилище доверия, чтобы включить самоподписанный сертификат(ы). Какое именно хранилище нужно настроить, зависит от того, что вы тестируете.

* Это может быть ОС для сервера и некоторых клиентов.
* Runtime‑окружение для других клиентов, таких как Java, Python или Node.js.
* Ваш браузер для мониторинговых endpoint и websockets.

Проверьте документацию вашей системы о том, как доверять конкретному самоподписанному сертификату.

<a id="missing-subject-alternative-name"></a>
#### Отсутствие Subject Alternative Name

Еще одна частая проблема — проваленная [проверка идентичности](https://tools.ietf.org/html/rfc6125). IP или DNS‑имя для подключения должно совпадать с [Subject Alternative Name (SAN)](https://tools.ietf.org/html/rfc4985) внутри сертификата. То есть, если клиент/браузер/сервер подключается по TLS к `127.0.0.1`, сервер должен предъявить сертификат с SAN, содержащим IP `127.0.0.1`, иначе соединение будет закрыто с ошибкой рукопожатия.

Когда указано `verify_cert_and_check_known_urls`, необходимы `DNS` записи [Subject Alternative Name (SAN)](https://tools.ietf.org/html/rfc4985). Для успешного подключения должен быть перекрестный набор `DNS` записей в сертификате и URL в конфигурации. Если вы динамически расширяете кластер и используете новый сертификат, то route или gateway, к которым подключается сервер, должны быть переконфигурированы, чтобы включить URL нового сервера. Только тогда новый сервер сможет подключиться. Если `DNS` запись — wildcard, сопоставление выполняется согласно [rfc6125](https://tools.ietf.org/html/rfc6125#section-6.4.1). Сертификаты с wildcard SAN и конфигурация с URL, которые будут совпадать, — способ сохранить гибкость динамического роста кластера без изменений конфигурации в других кластерах.

#### Неверное назначение ключа

При генерации сертификата нужно убедиться, что включено правильное назначение, для которого будет использоваться сертификат. Это закодировано в [key usage](https://tools.ietf.org/html/rfc5280#section-4.2.1.3) и [extended key usage](https://tools.ietf.org/html/rfc5280#section-4.2.1.12). Необходимые значения key usage зависят от используемых cipher’ов. `Digital Signature` и `Key Encipherment` — совместимый выбор.

Для NATS важны следующие значения extended key usage:

* `TLS WWW server authentication` — для аутентификации в роли сервера для входящих соединений. Сервер NATS должен иметь сертификат с этим значением.
* `TLS WWW client authentication` — для аутентификации в роли клиента для исходящих соединений. Нужен только при подключении к серверу, где указаны `verify`, `verify_and_map` или `verify_cert_and_check_known_urls`. В этих случаях клиент NATS должен иметь сертификат с этим значением.
  * [Leaf node](../leafnodes/) подключения также могут быть настроены с `verify`. Тогда подключающийся сервер NATS тоже должен предъявить сертификат с этим значением. Сертификаты с обоими значениями — вариант.
  * [Cluster](../clustering/) подключения всегда имеют `verify` включенным. Какой сервер выступает клиентом и сервером зависит от времени, поэтому нельзя настроить отдельно. Сертификаты с обоими значениями обязательны.
  * [Gateway](../gateways/) подключения всегда имеют `verify` включенным. В отличие от cluster, исходящие соединения могут задавать отдельный сертификат. Сертификаты с обоими значениями — вариант, уменьшающий конфигурацию.

Обратите внимание: это распространенная практика для не‑web протоколов — использовать поля `TLS WWW` аутентификации. Исторически они стали общими опциями.

### Создание самоподписанных сертификатов для тестирования

Самый простой способ сгенерировать CA, а также клиентские и серверные сертификаты — [mkcert](https://github.com/FiloSottile/mkcert). Этот инструмент без настройки генерирует и устанавливает CA в **локальные** хранилища доверия и упрощает работу с SAN. См. его [документацию](https://github.com/FiloSottile/mkcert/blob/master/README.md) по установке и хранилищам доверия. Простой пример:

Сгенерировать CA и сертификат, валидный для серверной аутентификации по `localhost` и IP `::1` (опции `-cert-file` и `-key-file` переопределяют имена файлов по умолчанию). Затем запустить NATS сервер с этим сертификатом.

```bash
mkcert -install
mkcert -cert-file server-cert.pem -key-file server-key.pem localhost ::1
nats-server --tls --tlscert=server-cert.pem --tlskey=server-key.pem -ms 8222
```

Теперь вы должны иметь доступ к endpoint мониторинга `https://localhost:8222` в браузере.
`https://127.0.0.1:8222` при этом даст ошибку, так как `127.0.0.1` не указан в SAN. Вы также не сможете установить соединение с другого компьютера. Для этого нужно добавить соответствующие DNS и/или IP [SAN](tls.md#missing-subject-alternative-name).

Чтобы сгенерировать сертификаты, работающие с `verify` и [`cluster`](../clustering/)/[`gateway`](../gateways/)/[`leaf_nodes`](../leafnodes/), используйте опцию `-client`. Это добавит необходимые key usage для клиентской аутентификации. В этом примере также добавляется SAN‑email для использования в качестве имени пользователя при `verify_and_map`.

```bash
mkcert -client -cert-file client-cert.pem -key-file client-key.pem localhost ::1 email@localhost
```

> Обратите внимание:
>
> * client относится к процессу подключения, не обязательно к NATS‑клиенту.
> * `mkcert -client` сгенерирует сертификат с key usage, подходящим для клиентской **и** серверной аутентификации.

Примеры в этом документе используют сертификаты, сгенерированные выше. Чтобы упростить примеры с использованием CA‑сертификата, скопируйте `rootCA.pem` в ту же папку, где были сгенерированы сертификаты. Чтобы узнать расположение CA‑сертификата, используйте команду:

```bash
mkcert -CAROOT
```

После завершения тестирования удалите CA из **локальных** хранилищ доверия.

```text
mkcert -uninstall
```

В качестве альтернативы можно использовать [openssl](https://www.openssl.org/) для [генерации сертификатов](https://www.digitalocean.com/community/tutorials/openssl-essentials-working-with-ssl-certificates-private-keys-and-csrs). Этот инструмент позволяет значительно больше настроек, но он **сложнее** и **не управляет** установкой в системные хранилища доверия.

Однако для инспекции сертификатов он очень удобен. Чтобы просмотреть сертификаты из примера выше, выполните команды:

```bash
openssl x509 -noout -text -in server-cert.pem
openssl x509 -noout -text -in client-cert.pem
```

## TLS‑terminating reverse proxies

Использование [TLS‑terminating reverse proxy](https://en.wikipedia.org/wiki/TLS_termination_proxy) с NATS требует специфичной конфигурации сервера.
В типичном сценарии прокси связь клиент‑прокси защищена, а прокси‑сервер — нет. Это вызывает "несоответствие", потому что сервер выглядит небезопасным,
но клиенту говорят подключаться безопасно. Чтобы исправить это, сервер нужно настроить как "tls available". Это делается пустым блоком `tls` и флагом `allow_non_tls`.

```
tls {}
allow_non_tls: true
```


После этого клиент может подключаться к прокси с обычной (языко‑специфичной) TLS‑конфигурацией. Убедитесь, что вы используете подходящую версию вашего клиентского драйвера.

| Клиент | Версия |
| --- | --- |
| nats.go | v1.31.0 |
| nats.js | 2024.1.2 |
| nats.java | 2.18.0  |
| nats.rs | 0.33 |
| nats.net.v2 | 2.0.0 |
| nats.net (v1) | 1.1.5 |
|||

### nats.js

См.: <https://github.com/nats-io/nats.js/issues/369>

### nats.rs

См.: <https://github.com/nats-io/nats.rs/blob/main/async-nats/src/connector.rs>
