# Авторизация

Сервер NATS поддерживает авторизацию на основе прав уровня subject для каждого пользователя. Авторизация на основе прав доступна при мульти‑пользовательской аутентификации через список `users`.

Каждое правило определяет, на какие subjects пользователь может публиковать и подписываться. Парсер достаточно гибок, поэтому обрабатывает как массивы, так и одиночные значения. Для более сложной конфигурации можно задать объект `permission`, который явно разрешает или запрещает subjects. Указанные subjects могут содержать wildcards. Права могут использовать [переменные](authorization.md#variables).

Специальное поле внутри карты авторизации — `default_permissions`. Если оно задано, содержит права, которые применяются к пользователям, у которых нет собственных прав.

## Карта конфигурации прав

Карта `permissions` задает subjects, на которые указанный клиент может подписываться или публиковать.

| Свойство          | Описание                                                                                                                                                                                                                                                                                            |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `publish`         | subject, список subjects или [карта прав](authorization.md#permission-map), на которые клиент может публиковать                                                                                                                                                                                       |
| `subscribe`       | subject, список subjects или [карта прав](authorization.md#permission-map), на которые клиент может подписываться. В этом контексте можно указать необязательное имя очереди: `<subject> <queue>` для выражения прав на queue‑группы. Эти права также могут использовать wildcards, такие как `v2.*` или `>`. |
| `allow_responses` | boolean или [карта ответов](authorization.md#allow-responses-map), по умолчанию `false`. Включение неявно запрещает публикацию в другие subjects, однако явное `publish`‑разрешение на subject переопределит этот неявный запрет для этого subject.                                                   |

## Карта permission

Карта `permission` предоставляет дополнительные свойства для настройки карты `permissions`. Вместо списка разрешенных subjects и необязательных очередей, карта `permission` позволяет явно перечислить, что нужно `allow` или `deny`. Оба списка можно задавать. В случае пересечения приоритет у `deny`.

| Свойство | Описание                                               |
| -------- | ------------------------------------------------------ |
| `allow`  | Список subject, которые разрешены клиенту              |
| `deny`   | Список subject, которые запрещены клиенту              |

**Важное примечание** Важно не ломать паттерн request‑reply. В некоторых случаях (как показано [ниже](authorization.md#variables)) нужно добавить правила для `_INBOX.>` паттерна. Если неавторизованный клиент публикует или пытается подписаться на subject, который не находится в списке разрешенных, действие завершается ошибкой, логируется на сервере, и клиенту возвращается сообщение об ошибке. Опция [allow responses](authorization.md#allow-responses-map) может упростить это.

## Карта allow responses

Опция `allow_responses` динамически разрешает публикацию в reply‑subjects и предназначена для [service](../../../nats-concepts/core-nats/request-reply/reqreply.md) responders. При `true` применяется неявное _разрешение публикации_, которое дает сервису временное право публиковать в subject `reply` во время обмена request‑reply. Если `true`, клиент поддерживает одноразовую публикацию. Если `allow_responses` — это карта, можно настроить максимальное число ответов и срок действия разрешения.

{% hint style="danger" %}
Обратите внимание: когда `allow_responses` включен, reply‑subject не ограничен списком allow/deny для `publish`. Это означает, что reply‑subject может быть задан клиентом сервису (responder), у которого нет явного права публиковать в этот subject, но временно разрешено благодаря этой опции. Если нужен строгий контроль, на какие subjects клиент может отвечать, не используйте `allow_responses`, а вместо этого задайте allow/deny списки в карте `publish`.
{% endhint %}

| Свойство  | Описание                                                                                                                                                   |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `max`     | Максимальное количество сообщений‑ответов, которые можно опубликовать.                                                                                    |
| `expires` | Время, в течение которого разрешение действует. Можно задавать `1s`, `1m`, `1h` (1 секунда, минута, час) и т. д. По умолчанию ограничений по времени нет. |

Когда `allow_responses` установлено в `true`, по умолчанию это эквивалент `{ max: 1 }` и без ограничения по времени.

**Важное примечание** При использовании `nsc` для настройки пользователей, можно указать `--allow-pub-response` и `--response-ttl` для управления этими настройками.

## Примеры

### Переменные

Ниже пример конфигурации авторизации с _переменными_, которая определяет четырех пользователей, троим из которых назначены явные права.

```
authorization {
  default_permissions = {
    publish = "SANDBOX.*"
    subscribe = ["PUBLIC.>", "_INBOX.>"]
  }
  ADMIN = {
    publish = ">"
    subscribe = ">"
  }
  REQUESTOR = {
    publish = ["req.a", "req.b"]
    subscribe = "_INBOX.>"
  }
  RESPONDER = {
    subscribe = ["req.a", "req.b"]
    publish = "_INBOX.>"
  }
  users = [
    {user: admin,   password: $ADMIN_PASS, permissions: $ADMIN}
    {user: client,  password: $CLIENT_PASS, permissions: $REQUESTOR}
    {user: service,  password: $SERVICE_PASS, permissions: $RESPONDER}
    {user: other, password: $OTHER_PASS}
  ]
}
```

> `default_permissions` — специальная запись. Если определена, применяется ко всем пользователям, у которых нет собственных прав.

* _admin_ имеет права `ADMIN` и может публиковать/подписываться на любой subject. Мы используем wildcard `>`, чтобы соответствовать любому subject.
* _client_ — это `REQUESTOR`, может публиковать запросы на subjects `req.a` или `req.b` и подписываться на ответы (`_INBOX.>`).
* _service_ — это `RESPONDER` на запросы `req.a` и `req.b`, поэтому должен подписываться на subjects запросов и отвечать клиентам, которые публикуют запросы на `req.a` и `req.b`. Reply‑subject — это inbox. Обычно inbox’ы начинаются с префикса `_INBOX.` и далее идет сгенерированная строка. Subject `_INBOX.>` соответствует всем subject, начинающимся с `_INBOX.`.
* _other_ не имеет назначенных прав и наследует права по умолчанию.

> Обратите внимание: в примере выше любой клиент, имеющий право подписываться на `_INBOX.>`, может получать _все_ ответы. Более чувствительные установки захотят добавить или сузить префикс, чтобы дополнительно ограничить subjects, на которые клиент может подписываться. В качестве альтернативы, [_Accounts_](accounts.md) дают полную изоляцию, ограничивая то, что видят участники аккаунта.

### Явные allow/deny

Ниже пример без переменных, где явно заданы `allow` и `deny`:

```
authorization: {
    users = [
        {
            user: admin
            password: secret
            permissions: {
                publish: ">"
                subscribe: ">"
            }
        }
        {
            user: test
            password: test
            permissions: {
                publish: {
                    deny: ">"
                },
                subscribe: {
                    allow: "client.>"
                }
            }
        }
    ]
}
```

### allow_responses

Пример с `allow_responses`:

```
authorization: {
    users: [
        { user: a, password: a },
        { user: b, password: b, permissions: {subscribe: "q", allow_responses: true } },
        { user: c, password: c, permissions: {subscribe: "q", allow_responses: { max: 5, expires: "1m" } } }
        { user: d, password: d, permissions: {subscribe: "q", publish: "x", allow_responses: true } }
    ]
}
```

* Пользователь `a` без ограничений.
* Пользователь `b` слушает `q` на запросы и может публиковать ответ только один раз. _Все остальные subjects для публикации неявно запрещены, когда включен `allow_responses`._
* Пользователь `c` слушает `q` на запросы, но может вернуть максимум 5 ответных сообщений, и reply‑subject может публиковаться не более `1` минуты.
* Пользователь `d` ведет себя как пользователь `b`, но также может явно публиковать в subject `x`, что переопределяет неявный запрет от `allow_responses`.

### Права на очереди

Пользователь `a` может подписываться только на `foo` как часть queue‑подписок `queue`. Пользователь `b` имеет права как на queue‑подписки, так и на обычные подписки. Вы можете разрешить обычные подписки на `foo`, но ограничить, в какие очереди клиент может вступать, а также запретить любому сервису использовать queue‑подписку с именем `*.prod`:

```
users = [
  {
    user: "a", password: "a", permissions: {
      sub: {
        allow: ["foo queue"]
     }
  }
  {
    user: "b", password: "b", permissions: {
      sub: {
        # Разрешаем обычную подписку foo, но только v1 группы или *.dev queue‑группы
        allow: ["foo", "foo v1", "foo v1.>", "foo *.dev"]

        # Запрещаем queue‑подписки на prod‑группы
        deny: ["> *.prod"]
     }
  }
]
```
