# Мульти‑тенантность с помощью Accounts

В современной архитектуре микросервисов часто используют общую инфраструктуру — такую как NATS — между сервисами. [Accounts](accounts.md#accounts) — это безопасно изолированные контексты коммуникации, которые позволяют реализовать мульти‑тенантность в развертывании NATS. Они позволяют разделять технологию и бизнес‑сценарии, где данные изолируются по дизайну, а не из‑за ограничений ПО. Кроме того, они обеспечивают [контролируемый обмен](accounts.md#exporting-and-importing) информацией между такими «силосами»/тенантами/аккаунтами.

<a id="accounts"></a>
## Accounts

_Accounts_ расширяют основу авторизации. При традиционной авторизации все клиенты могут публиковать и подписываться на что угодно, если это явно не ограничено. Чтобы защитить клиентов и информацию, нужно аккуратно «резать» пространство subject и права клиентов.

_Accounts_ позволяют группировать клиентов, _изолируя_ их от клиентов других аккаунтов, тем самым обеспечивая _мульти‑тенантность_ на сервере. При использовании accounts пространство subject не является общим, что значительно упрощает среду обмена сообщениями. Вместо сложных схем «нарезки» имен subject, клиенты могут использовать короткие subject без явных правил авторизации. [System Events](../sys_accounts/) — пример такой изоляции в действии.

Конфигурация accounts задается в карте `accounts`. Содержимое записи аккаунта включает:

| Свойство | Описание |
| :--- | :--- |
| `users` | список [карт конфигурации пользователя](auth_intro/#user-configuration-map) |
| `exports` | список [карт экспорта](accounts.md#export-configuration-map) |
| `imports` | список [карт импорта](accounts.md#import-configuration-map) |

Список `accounts` — это map, где ключи — имена аккаунтов.

```text
accounts: {
    A: {
        users: [
            {user: a, password: a}
        ]
    },
    B: {
        users: [
            {user: b, password: b}
        ]
    },
}
```

> В самой простой конфигурации выше есть аккаунт `A` с одним пользователем (username `a`, password `a`) и аккаунт `B` с пользователем (username `b`, password `b`).
>
> Эти два аккаунта изолированы друг от друга. Сообщения, опубликованные пользователями из `A`, не видны пользователям `B`.
>
> Карта конфигурации пользователя — такая же, как любая другая карта пользователя NATS [user configuration map](auth_intro/#user-configuration-map). Можно использовать:
>
> * username/password
> * nkeys
> * и добавлять permissions
>
> Хотя название _account_ подразумевает одного или нескольких пользователей, гораздо проще и полезнее думать об аккаунте как о контейнере сообщений для одного приложения. Пользователи в аккаунте — это минимальный набор сервисов, которые должны работать вместе, чтобы обеспечить некоторую функциональность. Проще говоря, больше аккаунтов с малым числом клиентов (даже один) — это лучшая топология, чем один большой аккаунт с множеством пользователей и сложной конфигурацией авторизации.

<a id="exporting-and-importing"></a>
## Экспорт и импорт

Обмен сообщениями между разными аккаунтами включается путем _экспорта_ стримов и сервисов из одного аккаунта и _импорта_ их в другой. Каждый аккаунт контролирует, что экспортируется и что импортируется.

* **Streams** — сообщения, которые публикует ваше приложение. Импортирующие приложения не смогут делать запросы к вашим приложениям, но смогут потреблять сообщения, которые вы генерируете.
* **Services** — сообщения, которые ваше приложение может потреблять и обрабатывать, позволяя другим аккаунтам делать запросы, которые будут удовлетворены вашим аккаунтом.

{% hint style="info" %}
Термин `stream` в контексте импорта/экспорта аккаунтов *не* относится к JetStream stream (неудачное совпадение терминов, так как import/export между аккаунтами появился раньше JetStream). Это просто «поток (Core NATS) сообщений».
{% endhint %}

Список конфигурации `exports` позволяет определить сервисы и стримы, которые другие могут импортировать. Экспортируемые сервисы и стримы описываются [картой конфигурации Export](accounts.md#export-configuration-map). Список `imports` определяет сервисы и стримы, которые аккаунт импортирует. Импортируемые сервисы и стримы описываются [картой конфигурации Import](accounts.md#import-configuration-map).

<a id="export-configuration-map"></a>
### Карта конфигурации Export

Карта конфигурации Export привязывает subject для использования как `service` или `stream` и опционально определяет конкретные аккаунты, которые могут импортировать стрим или сервис. Поддерживаемые свойства:

| Свойство | Описание |
| :--- | :--- |
| `stream` | subject или subject с wildcard, который аккаунт будет публиковать. (взаимоисключается с `service`) |
| `service` | subject или subject с wildcard, на который аккаунт будет подписываться. (взаимоисключается с `stream`) |
| `accounts` | Список имен аккаунтов, которые могут импортировать стрим или сервис. Если не задано, сервис или стрим публичный, и любой аккаунт может его импортировать. |
| `response_type` | Указывает, состоит ли ответ на запрос `service` из `single` или `stream` сообщений. Возможные значения: `single` или `stream`. (Значение по умолчанию `singleton`) |

Примеры экспортов:

```text
accounts: {
    A: {
        users: [
            {user: a, password: a}
        ]
        exports: [
            {stream: puba.>}
            {service: pubq.>}
            {stream: b.>, accounts: [B]}
            {service: q.b, accounts: [B]}
        ]
    }
    ...
}
```

Что экспортирует `A`:

* публичный stream на wildcard‑subject `puba.>`
* публичный service на wildcard‑subject `pubq.>`
* stream для аккаунта `B` на wildcard‑subject `b.>`
* service для аккаунта `B` на subject `q.b`

<a id="import-configuration-map"></a>
### Карта конфигурации Import

Import позволяет аккаунту потреблять стримы, публикуемые другим аккаунтом, или делать запросы к сервисам, реализованным другим аккаунтом. Все импорты требуют соответствующего экспорта в аккаунте‑источнике. Аккаунты не могут импортировать сами у себя.

| Свойство | Описание |
| :--- | :--- |
| `stream` | Источник импорта stream [source configuration](accounts.md#source-configuration-map). (взаимоисключается с `service`) |
| `service` | Источник импорта service [source configuration](accounts.md#source-configuration-map) (взаимоисключается с `stream`) |
| `prefix` | Локальный префикс subject для импортируемого stream. (применимо к `stream`) |
| `to` | Локальное отображение subject для импортируемого service. (применимо к `service`) |

Опции `prefix` и `to` необязательны и позволяют перемаппить subject, который используется локально для получения сообщений из stream или отправки запросов к service. Так импортирующий аккаунт не зависит от соглашений именования другого аккаунта. Сейчас импорт service не может использовать wildcard, поэтому subject импорта может быть переписан. Импорт stream может использовать wildcard. Чтобы сохранить информацию, содержащуюся в subject, его можно только префиксировать `prefix`...

<a id="source-configuration-map"></a>
#### Карта конфигурации Source

_Карта конфигурации source_ описывает экспорт из удаленного аккаунта, указывая `account` и `subject` экспорта, который импортируется. Эта карта встраивается в [карту конфигурации import](accounts.md#import-configuration-map):

| Свойство | Описание |
| :--- | :--- |
| `account` | Имя аккаунта‑владельца экспорта. |
| `subject` | Subject, под которым stream или service доступен импортирующему аккаунту |

### Пример Import/Export

```text
accounts: {
    A: {
        users: [
            {user: a, password: a}
        ]
        exports: [
            {stream: puba.>}
            {service: pubq.>}
            {stream: b.>, accounts: [B]}
            {service: q.b, accounts: [B]}
        ]
    },
    B: {
        users: [
            {user: b, password: b}
        ]
        imports: [
            {stream: {account: A, subject: b.>}}
            {service: {account: A, subject: q.b}}
        ]
    }
    C: {
        users: [
            {user: c, password: c}
        ]
        imports: [
            {stream: {account: A, subject: puba.>}, prefix: from_a}
            {service: {account: A, subject: pubq.C}, to: Q}
        ]
    }
}
```

Аккаунт `B` импортирует:

* приватный stream из `A`, который может получать только `B` на `b.>`
* приватный service из `A`, на который только `B` может отправлять запросы на `q.b`

Аккаунт `C` импортирует публичные service и stream из `A`, а также:

* перемаппит stream `puba.>` так, чтобы он был локально доступен как `from_a.puba.>`. Сообщения сохраняют оригинальные subject с префиксом `from_a`.
* перемаппит service `pubq.C`, чтобы он был локально доступен как `Q`. Аккаунту `C` нужно публиковать локально в `Q`.

Важно подчеркнуть:

* stream `puba.>` из `A` виден всем внешним аккаунтам, которые импортируют этот stream.
* service `pubq.>` из `A` доступен всем внешним аккаунтам, если они знают полный subject, куда отправлять запрос. Обычно аккаунт экспортирует wildcard‑service и согласует с клиентским аккаунтом конкретные subject, на которые будут отвечать. В нашем примере аккаунт `C` обращается к сервису на `pubq.C` (но для удобства перемаппил в `Q`).
* stream `b.>` — приватный, только аккаунт `B` может получать сообщения из этого stream.
* service `q.b` — приватный; только аккаунт `B` может отправлять запросы к этому service.
* Когда `C` публикует запрос в `Q`, локальные клиенты `C` видят сообщения `Q`. Однако сервер перемаппит `Q` в `pubq.C` и переадресует запросы аккаунту `A`.

## No Auth User

Клиенты, подключающиеся без аутентификации, могут быть связаны с конкретным пользователем в аккаунте.

```text
accounts: {
    A: {
        users: [
            {user: a, password: a}
        ]
    },
    B: {
        users: [
            {user: b, password: b}
        ]
    }
}
no_auth_user: a
```

Пример выше показывает, как клиенты без аутентификации могут быть связаны с пользователем `a` в аккаунте `A`.

> Обратите внимание: `no_auth_user` не работает с nkeys или bcrypted‑паролями. Указанный пользователь также может быть частью блока [authorization](authorization.md).
>
> Несмотря на то, что `no_auth_user` задан, клиенты все равно должны сообщить, что они не будут использовать учетные данные. К этому процессу применяется [таймаут аутентификации](auth_intro/auth_timeout.md). При медленном соединении вы можете попасть на этот таймаут и получить ошибку `Authentication Timeout`, хотя учетные данные не предоставлялись.

### Экспорт и импорт JetStream‑потоков между аккаунтами

Можно импортировать/экспортировать сообщения, хранящиеся в JetStream‑потоках, между аккаунтами. Хотя можно разрешить клиентскому приложению в одном аккаунте доступ к потоку, расположенному в другом аккаунте, в большинстве случаев хотят конфигурацию, где поток в одном аккаунте зеркалируется или источником включается в другом аккаунте (и приложения в этом другом аккаунте используют этот зеркальный/источник‑поток в своем аккаунте). Это более «закрытый» способ делиться сообщениями между аккаунтами по сравнению с тем, чтобы дать клиентским приложениям прямой доступ к потоку в другом аккаунте.

Есть два ресурса с примерами того, как это сделать:
* [Cross account JetStream sourcing](https://github.com/synadia-labs/cross-account-jetstream-sourcing) — объясняет и содержит walkthrough‑пример с использованием простой статической безопасности (вероятно, лучший вариант для старта)
* [Connect Streams Cross Accounts](https://github.com/nats-io/jetstream-leaf-nodes-demo#connect-streams-cross-accounts) — объясняет то же самое, но при использовании JWT‑безопасности в режиме operator

# См. также

 * [Мульти‑тенантность и управление ресурсами](https://docs.nats.io/running-a-nats-service/configuration/resource_management#multi-tenancy-and-resource-mgmt)
