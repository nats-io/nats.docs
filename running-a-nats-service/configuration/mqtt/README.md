# MQTT

_Поддерживается начиная с NATS Server версии 2.2_

NATS максимально следует спецификации MQTT v3.1.1 [specification](https://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html). См. [обзор реализации MQTT](https://github.com/nats-io/nats-server/blob/main/server/README-MQTT.md) в репозитории nats-server.

NATS поддерживает MQTT QoS: 0, 1 и 2

## Когда использовать MQTT

Поддержка MQTT в NATS предназначена как «включающая» технология, позволяющая пользователям использовать существующие инвестиции в IoT‑развертываниях. Обновление ПО на edge или endpoints может быть тяжёлым и рискованным, особенно когда речь о встроенных приложениях.

В greenfield‑IoT‑развертываниях, когда это возможно, мы предпочитаем NATS, развернутый до конечных устройств, по нескольким причинам. Существенные преимущества в безопасности и наблюдаемости при использовании одной технологии «от края до края». По сравнению с MQTT, NATS почти так же легок по полосе протокола, а поддерживаемые мейнтейнерами клиенты эффективно используют ресурсы, поэтому мы считаем NATS хорошим выбором для использования end‑to‑end, включая устройства с ограниченными ресурсами.

В существующих MQTT‑развертываниях или в ситуациях, когда endpoints могут поддерживать только MQTT, использование сервера NATS как drop‑in замены MQTT‑брокера для безопасного подключения к удаленному кластеру или супер‑кластеру NATS — привлекательный вариант. Вы можете сохранить существующие IoT‑инвестиции и использовать NATS для безопасного, устойчивого и масштабируемого доступа к вашим стримам и сервисам.

## Требования JetStream

Чтобы MQTT‑клиент мог подключиться к серверу NATS, аккаунт пользователя должен быть JetStream‑включенным. Это нужно, потому что для сессий и retained‑сообщений требуется персистентность — retained‑сообщения QoS 0 также сохраняются.

## MQTT topics и NATS subjects

MQTT topics похожи на NATS subjects, но имеют отличия.

MQTT topic использует `"/"` как разделитель уровней. Например, `foo/bar` соответствует NATS subject `foo.bar`. Но в MQTT допустим subject `/foo/bar/`, который при прямом переводе стал бы `.foo.bar.`, а это НЕ допустимый NATS subject.

Сервер NATS конвертирует MQTT topic по следующим правилам:

|     Символ MQTT     |  Символы NATS  | Topic (MQTT) | Subject (NATS) |
| :-----------------: | :------------: | :----------: | :------------: |
| `/` между уровнями  |      `.`       |   `foo/bar`  |   `foo.bar`    |
| `/` как первый уровень |     `/.`    |  `/foo/bar`  |  `/.foo.bar`   |
| `/` как последний уровень | `./`     |  `foo/bar/`  |  `foo.bar./`   |
| `/` рядом с другим  |     `./`       |  `foo//bar`  |  `foo./.bar`   |
| `/` рядом с другим  |     `/.`       | `//foo/bar`  | `/./.foo.bar`  |
| `.`                | `//` (см. примечание ниже) | `foo.bar` | `foo//bar` |
| пробел             | Не поддерживается | `foo bar` | Не поддерживается |

_Примечание: до NATS Server v2.10.0 символ `.` не поддерживался. Начиная с v2.10.0 и выше, символ `.` будет переводиться в `//`._

Как указано выше, если MQTT topic содержит символ ` ` (или `.` до v2.10.0), NATS его отвергнет: для опубликованных сообщений соединение будет закрыто, а для подписок будет возвращен код ошибки в пакете SUBACK.

### MQTT wildcards

Как и в NATS, MQTT wildcards означают либо несколько уровней, либо один уровень. Как и в NATS, они допустимы только для подписок, но не для опубликованных сообщений.

| Wildcard MQTT | Wildcard NATS |
| :-----------: | :-----------: |
|      `#`      |      `>`      |
|      `+`      |      `*`      |

Wildcard `#` соответствует любому количеству уровней в topic, то есть подписка на `foo/#` будет получать сообщения на `foo/bar` или `foo/bar/baz`, но также и на `foo`. В NATS это не так: подписка на `foo.>` получает `foo/bar` или `foo/bar/baz`, но не `foo`. Чтобы решить это, сервер NATS создаст две подписки: одну на `foo.>` и одну на `foo`. Если MQTT‑подписка просто на `#`, то достаточно одной NATS‑подписки на `>`.

Wildcard `+` соответствует одному уровню, то есть `foo/+` получает сообщения на `foo/bar` или `foo/baz`, но не на `foo/bar/baz` и не на `foo`. То же самое в NATS с wildcard `*`. Поэтому `foo/+` переводится в `foo.*`.

## Взаимодействие между MQTT и NATS

Когда MQTT‑клиент создает подписку на topic, сервер NATS создает соответствующую NATS‑подписку (с конвертацией MQTT topic в NATS subject), чтобы интерес был зарегистрирован в кластере и известен любым NATS‑издателям.

То есть, если MQTT‑клиент подключается к серверу "A" и создает подписку `foo/bar`, сервер "A" создает подписку на `foo.bar`, и этот интерес распространяется как любая другая подписка NATS. Издатель, подключенный в любом месте кластера и публикующий в `foo.bar`, приведет к доставке QoS 0‑сообщения в MQTT‑подписку.

То же самое работает для MQTT‑издателей. Когда сервер получает MQTT publish‑сообщение, оно конвертируется в NATS subject и публикуется, а значит любая подходящая NATS‑подписка получит MQTT‑сообщение.

Если MQTT‑подписка QoS1 и MQTT‑издатель публикует MQTT QoS1‑сообщение на том же или любом другом сервере в кластере, сообщение будет персистентно сохранено в кластере, маршрутизировано и доставлено как QoS1 в MQTT‑подписку.

## Повторные доставки QoS 1 и 2

Когда сервер доставляет сообщение QoS 1 или 2 в подписку QoS 1 или 2, он сохраняет сообщение до получения PUBACK для соответствующего идентификатора пакета. Если PUBACK не приходит в течение интервала `ack_wait`, сообщение будет отправлено повторно.

## Max Ack Pending

Это количество QoS 1 или 2 сообщений, которые сервер может отправить подписке, не получив PUBACK на них. Максимум — 65535.

Суммарный `max_ack_pending` всех подписок в одной сессии не может превышать 65535. Попытка создать подписку, которая превысит лимит, приведет к возврату кода ошибки в SUBACK для этой подписки.

Из‑за того, как сервер NATS обрабатывает wildcard MQTT `"#"`, каждая подписка, заканчивающаяся на `"#"`, будет использовать в 2 раза больше значения `max_ack_pending`.

## Сессии

Сервер NATS сохраняет все сессии, даже если они созданы с флагом "clean session", то есть сессии живут только в течение сетевого соединения между клиентом и сервером.

Сессия идентифицируется клиентским идентификатором. Если два соединения используют один и тот же client identifier, сервер, согласно спецификации, закроет существующее соединение и примет новое.

Если пользователь ошибочно запускает два приложения с одним и тем же client identifier, это приведет к очень быстрому «флаппингу», если MQTT‑клиент умеет быстро переподключаться.

Чтобы предотвратить это, сервер NATS примет новую сессию и задержит закрытие старого соединения, уменьшая скорость флаппинга.

Обнаружение параллельного использования сессий также работает в режиме кластера.

## Retained‑сообщения

Когда сервер получает MQTT publish‑пакет с установленным флагом RETAIN (независимо от QoS), он сохраняет сообщение приложения и его QoS, чтобы позже доставить его будущим подписчикам, чьи подписки совпадают с именем topic.

При создании новой подписки последнее retained‑сообщение (если есть) по каждому совпадающему topic будет отправлено подписчику.

PUBLISH‑пакет с флагом RETAIN = 1 и payload нулевой длины будет обработан как обычно и отправлен клиентам с подпиской на соответствующий topic. Дополнительно любое существующее retained‑сообщение с тем же topic будет удалено, и будущие подписчики не получат retained‑сообщение.

## Кластеризация

NATS поддерживает MQTT в кластере NATS. Коэффициент репликации автоматически устанавливается на основе размера кластера.

### Подключения с одинаковым Client ID

Если клиент подключен к серверу "A" в кластере, а другой клиент подключается к серверу "B" и использует тот же client identifier, сервер "A" закроет клиентское соединение после обнаружения активного client identifier.

Пользователям следует избегать этой ситуации, так как это не так просто и не так быстро, как если бы оба приложения были подключены к одному серверу.

В некоторых случаях сервер может отклонить новое подключение, если нет безопасного способа закрыть существующее соединение, например, когда сервер находится в процессе обработки MQTT‑пакетов.

### Retained‑сообщения

Retained‑сообщения хранятся в кластере и доступны на любом сервере кластера. Однако это не мгновенно: если продюсер подключается к серверу и публикует retained‑сообщение, а другое соединение подключается к другому серверу и начинает подписку, оно может не получить retained‑сообщение, если сервер, к которому оно подключено, еще не узнал о нем.

Иными словами, retained‑сообщения в режиме кластера — best‑effort, и приложения, которые зависят от наличия retained‑сообщения, должны подключаться к серверу, который их публикует.

## Ограничения

- Сообщения NATS, публикуемые в MQTT‑подписки, всегда доставляются как QoS 0.
- MQTT‑сообщения, публикуемые на topic, содержащие символы "````" или "`.`", приведут к закрытию соединения. Наличие этих символов в MQTT‑подписках приведет к коду ошибки в SUBACK.
- MQTT wildcard `#` может привести к тому, что сервер NATS создаст две подписки.
- Параллельные MQTT‑сессии могут приводить к тому, что будет вытеснено новое подключение вместо существующего.
- Retained‑сообщения MQTT в режиме кластера — best‑effort.

## См. также

[Замените MQTT‑брокер на NATS Server](https://nats.io/blog/replace-your-mqtt-broker-with-nats/)
