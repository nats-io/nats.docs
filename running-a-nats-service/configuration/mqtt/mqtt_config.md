---
description: MQTT Configuration Example
---

# Конфигурация

Чтобы включить поддержку MQTT на сервере, добавьте блок `mqtt` в конфигурационный файл сервера, например так:

```text
mqtt {
    # Укажите host и порт, на котором слушать MQTT‑подключения
    #
    # listen: "host:port"
    # Можно также настроить отдельными параметрами,
    # а именно host и port.
    #
    # host: "hostname"
    port: 1883

    # Конфигурация TLS.
    #
    tls {
        cert_file: "/path/to/cert.pem"
        key_file: "/path/to/key.pem"

        # Root CA файл
        #
        # ca_file: "/path/to/ca.pem"

        # Если true, требовать и проверять клиентские сертификаты.
        #
        # verify: true

        # Таймаут TLS‑рукопожатия в дробных секундах.
        #
        # timeout: 2.0

        # Если true, требовать и проверять клиентские сертификаты и
        # маппить значения сертификата для целей аутентификации.
        #
        # verify_and_map: true
    }

    # Если при подключении MQTT‑клиента не указано имя пользователя,
    # будет использовано это имя по умолчанию на этапе аутентификации.
    # Если задано, это значение для MQTT‑клиентов переопределит любое
    # `no_auth_user`, определенное в основном конфиге.
    # Обратите внимание, что это несовместимо с operator mode.
    #
    # no_auth_user: "my_username_for_apps_not_providing_credentials"

    # См. ниже, как обычно ограничивать MQTT‑клиентов конкретными пользователями.
    # Если в конфигурации не указаны пользователи, этот простой блок авторизации
    # позволяет переопределить значения, которые были бы настроены в эквивалентном
    # блоке основной секции.
    #
    # authorization {
    #     # Если указано, клиент должен предоставить то же имя пользователя
    #     # и пароль для подключения.
    #     # username: "my_user_name"
    #     # password: "my_password"
    #
    #     # Если указано, поле password в пакете CONNECT должно совпадать с этим токеном.
    #     # token: "my_token"
    #
    #     # Переопределяет таймаут авторизации основной конфигурации. Для согласованности
    #     # с основным блоком авторизации это выражено в секундах.
    #     # timeout: 2.0
    #}

    # Время, после которого QoS 1 сообщение, отправленное клиенту,
    # будет повторно доставлено как DUPLICATE, если сервер не получил
    # пакет PUBACK для исходного идентификатора пакета.
    # Значение должно быть положительным.
    # Ноль приведет к использованию значения по умолчанию (30 секунд).
    # Изменения этой опции применяются только к новым MQTT‑подпискам.
    #
    # Задается как длительность времени, где "s", "m", "h" означают секунды,
    # минуты и часы соответственно. Например "10s" для 10 секунд,
    # "1m" для 1 минуты и т. д.
    #
    # ack_wait: "1m"

    # Количество QoS 1 сообщений, которые сервер может отправить
    # подписке, не получив PUBACK на эти сообщения.
    # Допустимый диапазон [0..65535].
    #
    # Суммарный max_ack_pending всех подписок в одной сессии не может
    # превышать 65535. Попытка создать подписку, которая превысит лимит,
    # приведет к тому, что сервер вернет 0x80 в SUBACK для этой подписки.
    # Из‑за того, как сервер NATS обрабатывает wildcard MQTT "#", каждая
    # подписка, заканчивающаяся на "#", будет использовать в 2 раза больше
    # значения max_ack_pending.
    # Изменения этой опции применяются только к новым подпискам.
    #
    # max_ack_pending: 100
}
```

## Имя сервера

MQTT требует, чтобы было задано имя сервера. Имена серверов должны быть уникальны в топологии кластера или супер‑кластера. Имя сервера задается в верхнем уровне конфигурации. Пример:
```
server_name: "my_mqtt_server"
mqtt {
    port: 1883
    ...
}
```

## Аутентификация/авторизация пользователей MQTT

### Operator mode

В operator mode все пользователи должны предоставлять JWT для подключения. В стандартной процедуре аутентификации этого режима NATS‑клиенты должны подписывать `nonce`, отправленный сервером, своим приватным ключом (см. [JWTs and Privacy](../securing_nats/jwt/#jwts-and-privacy)). MQTT‑клиенты не могут этого сделать, поэтому JWT используется для аутентификации, устраняя необходимость seed. Это означает, что вам нужно передать JWT‑токен как пароль MQTT и использовать любое имя пользователя (кроме пустого, так как протокол MQTT требует, чтобы имя пользователя было задано при наличии пароля). JWT должен иметь `Bearer` = true, что можно сделать через nsc:

```shell
nsc edit user --name U --account A --bearer
```

### Local mode

Новое поле при настройке пользователей позволяет ограничить, какие типы соединений разрешены для конкретного пользователя.

Рассмотрим конфигурацию:

```text
authorization {
  users [
    {user: foo password: foopwd, permission: {...}}
    {user: bar password: barpwd, permission: {...}}
  ]
}
```

Если MQTT‑клиент подключится с именем пользователя `foo` и паролем `foopwd`, он будет принят. Теперь предположим, что вы хотите принимать MQTT‑клиентов только при подключении с именем `bar` и паролем `barpwd`, тогда используйте опцию `allowed_connection_types`, чтобы ограничить типы соединений, которые могут привязываться к этому пользователю.

```text
authorization {
  users [
    {user: foo password: foopwd, permission: {...}}
    {user: bar password: barpwd, permission: {...}, allowed_connection_types: ["MQTT"]}
  ]
}
```

Опция `allowed_connection_types` (также может называться `connection_types` или `clients`), как видно, является списком, и вы можете разрешить несколько типов клиентов. Допустим, вы хотите, чтобы пользователь `bar` принимал как стандартные NATS‑клиенты, так и MQTT‑клиенты — тогда настройка будет такой:

```text
authorization {
  users [
    {user: foo password: foopwd, permission: {...}}
    {user: bar password: barpwd, permission: {...}, allowed_connection_types: ["STANDARD", "MQTT"]}
  ]
}
```

Отсутствие `allowed_connection_types` означает, что разрешены все типы соединений (поведение по умолчанию).

Возможные значения сейчас:

* `STANDARD`
* `WEBSOCKET`
* `LEAFNODE`
* `MQTT`

### Специальные разрешения

Когда MQTT‑клиент создает подписку QoS 1, это приводит к созданию durable‑подписки JetStream. Чтобы получать сообщения для этой durable‑подписки, сервер NATS создает подписку с subject вида `$MQTT.sub.<nuid>` и устанавливает его как delivery subject для durable‑подписки JetStream.

Следовательно, если вы задали права для пользователя MQTT, нужно разрешить права subscribe на `$MQTT.sub.>`.

Ниже пример базовой конфигурации, задающей права для пользователя с именем "mqtt". Как видно, добавлено subscribe‑разрешение `$MQTT.sub.>`, чтобы этот клиент мог создавать подписки QoS 1.

```text
    listen: 127.0.0.1:4222
    jetstream: enabled
    authorization {
        mqtt_perms = {
            publish = ["baz"]
            subscribe = ["foo", "bar", "$MQTT.sub.>"]
        }
        users = [
            {user: mqtt, password: pass, permissions: $mqtt_perms, allowed_connection_types: ["MQTT"]}
        ]
    }
    mqtt {
        listen: 127.0.0.1:1883
    }
```
