# Кластеризация JetStream

Кластеризация в JetStream необходима для высокой доступности и масштабируемости. В основе кластеризации — RAFT. Глубоко понимать RAFT для использования кластеризации не нужно, но базовые знания объясняют часть требований к настройке кластеров JetStream.

## RAFT

JetStream использует оптимизированный для NATS алгоритм RAFT для кластеризации. Обычно RAFT генерирует много трафика, но сервер NATS оптимизирует это, объединяя плоскость данных для репликации сообщений с сообщениями RAFT, которые обычно используются для обеспечения консенсуса. Каждый сервер‑участник должен иметь уникальное `server_name` (применимо только внутри одного домена).

### Группы RAFT

Группы RAFT включают обработчики API, streams, consumers, а внутренний алгоритм определяет, какие серверы обрабатывают какие потоки и consumers.

Алгоритм RAFT имеет несколько требований:

* Лог для персистентного хранения состояния
* Кворум для консенсуса

### Кворум

Чтобы обеспечить консистентность данных после полных перезапусков, требуется кворум серверов. Кворум — это ½ размера кластера + 1. Это минимальное число узлов, гарантирующее, что хотя бы один узел имеет самые свежие данные и состояние после катастрофического отказа. Так, для кластера из 3 узлов нужны как минимум два NATS‑сервера с включенным JetStream, доступные для хранения новых сообщений. Для кластера из 5 — как минимум 3 сервера и так далее.

### Группы RAFT

**Meta Group** — все серверы входят в Meta Group, и JetStream API управляется этой группой. Выбирается лидер, который владеет API и занимается размещением серверов.

![Meta Group](../../../../.gitbook/assets/meta-group.png)

**Stream Group** — каждый Stream создает RAFT‑группу, эта группа синхронизирует состояние и данные между участниками. Выбранный лидер обрабатывает ACK’и и т. п. Если лидера нет, поток не принимает сообщения.

![Stream Groups](../../../../.gitbook/assets/stream-groups.png)

**Consumer Group** — каждый Consumer создает RAFT‑группу, которая синхронизирует состояние consumer’а между участниками. Группа будет жить на тех же машинах, что и Stream Group, и обрабатывать ACK’и потребления и т. п. У каждого Consumer — своя группа.

![Consumer Groups](../../../../.gitbook/assets/consumer-groups.png)

### Размер кластера

В общем случае мы рекомендуем 3 или 5 серверов с включенным JetStream в кластере NATS. Это балансирует масштабируемость и устойчивость к отказам. Например, если 5 серверов имеют JetStream, разумно держать два сервера в одной «зоне», два — в другой, а оставшийся — в третьей. Это означает, что вы можете потерять любую одну «зону» в любой момент и продолжать работу.

### Смешивание серверов с JetStream и обычных NATS‑серверов

Это возможно и в некоторых случаях даже рекомендуется. Смешивая типы серверов, можно выделить машины, оптимизированные под хранение, для JetStream, и машины, оптимизированные под вычисления, для обычных NATS‑серверов, снижая операционные расходы. При правильной конфигурации обычные серверы будут обрабатывать неперсистентный трафик NATS, а серверы с JetStream — трафик JetStream.

## Конфигурация

Чтобы настроить кластер JetStream, настраивайте кластер как обычно, задав блок cluster в конфигурации. Любые серверы с включенным JetStream в списке кластеров автоматически начнут «общаться» и настроятся. В отличие от core NATS кластеризации, каждый узел JetStream **должен указать** имя сервера и имя кластера.

Ниже приведены явные конфигурации серверов для кластера из трех узлов на трех машинах: `n1-c1`, `n2-c1` и `n3-c1`.

### Конфигурация пароля сервера

Нужно настроить пользователя и пароль под [системным аккаунтом ($SYS)](../../sys_accounts/#system-account). В следующей конфигурации используется [bcrypt‑пароль](../../securing_nats/auth_intro/username_password.md): `a very long s3cr3t! password`.

### Сервер 1 (host_a)

```
server_name=n1-c1
listen=4222

accounts {
  $SYS {
    users = [
      { user: "admin",
        pass: "$2a$11$DRh4C0KNbNnD8K/hb/buWe1zPxEHrLEiDmuq1Mi0rRJiH/W25Qidm"
      }
    ]
  }
}

jetstream {
   store_dir=/nats/storage
}

cluster {
  name: C1
  listen: 0.0.0.0:6222
  routes: [
    nats://host_b:6222
    nats://host_c:6222
  ]
}
```

### Сервер 2 (host_b)

```
server_name=n2-c1
listen=4222

accounts {
  $SYS {
    users = [
      { user: "admin",
        pass: "$2a$11$DRh4C0KNbNnD8K/hb/buWe1zPxEHrLEiDmuq1Mi0rRJiH/W25Qidm"
      }
    ]
  }
}

jetstream {
   store_dir=/nats/storage
}

cluster {
  name: C1
  listen: 0.0.0.0:6222
  routes: [
    nats://host_a:6222
    nats://host_c:6222
  ]
}
```

### Сервер 3 (host_c)

```
server_name=n3-c1
listen=4222

accounts {
  $SYS {
    users = [
      { user: "admin",
        pass: "$2a$11$DRh4C0KNbNnD8K/hb/buWe1zPxEHrLEiDmuq1Mi0rRJiH/W25Qidm"
      }
    ]
  }
}

jetstream {
   store_dir=/nats/storage
}

cluster {
  name: C1
  listen: 0.0.0.0:6222
  routes: [
    nats://host_a:6222
    nats://host_b:6222
  ]
}
```

Добавляйте узлы по мере необходимости. Выберите каталог данных, подходящий под вашу среду (в идеале быстрый SSD), и запустите каждый сервер. После запуска двух серверов вы будете готовы использовать JetStream.
