# Запрос‑ответ

Request‑Reply — распространенный паттерн в современных распределенных системах. Запрос отправляется, и приложение либо ждет ответ с тайм‑аутом, либо получает ответ асинхронно.

Рост сложности современных систем требует таких возможностей, как [прозрачность расположения](https://en.wikipedia.org/wiki/Location\_transparency), масштабирование вверх и вниз, наблюдаемость (измерение состояния системы по данным, которые она генерирует), и многое другое. Чтобы реализовать этот набор возможностей, многие технологии вынуждены добавлять дополнительные компоненты, сайдкары (процессы или сервисы, поддерживающие основное приложение) и прокси. NATS, напротив, реализует Request‑Reply гораздо проще.

### NATS делает Request‑Reply простым и мощным

* NATS поддерживает паттерн Request‑Reply через свой базовый механизм коммуникации — publish и subscribe. Запрос публикуется в заданный subject с использованием subject для ответа. Обработчики слушают этот subject и отправляют ответы на subject ответа. Subjects для ответа называются "**inbox**". Это уникальные subjects, которые динамически направляются обратно инициатору запроса, независимо от расположения сторон.
* Несколько обработчиков NATS могут образовывать динамические queue groups. Поэтому не нужно вручную добавлять или удалять подписчиков из группы, чтобы начать или прекратить распределение сообщений — это делается автоматически. Это позволяет обработчикам масштабироваться вверх и вниз по мере необходимости.
* Приложения NATS «drain before exiting» (обрабатывают буферизованные сообщения перед закрытием соединения). Это позволяет масштабироваться вниз, не теряя запросы.
* Поскольку NATS основан на publish‑subscribe, наблюдаемость достигается просто запуском еще одного приложения, которое может видеть запросы и ответы, измерять задержки, отслеживать аномалии, управлять масштабированием и т. д.
* Мощь NATS позволяет получать даже несколько ответов: используется первый, а остальные эффективно отбрасываются. Это дает возможность использовать несколько обработчиков, снижать задержку ответа и джиттер.

### Паттерн

![](../../../.gitbook/assets/reqrepl.svg)

Попробуйте NATS request‑reply самостоятельно, используя живой сервер, пройдя [пошаговое руководство по request‑reply.](reqreply\_walkthrough.md)

### Нет обработчиков

Когда запрос отправляется в subject без подписчиков, удобно узнать об этом сразу. Для этого клиент NATS может [включить сообщения no\_responder](../../../reference/nats-protocol/nats-protocol/#syntax-1). Это требует сервер и клиента с поддержкой заголовков. Если включено, запрос, отправленный в subject без подписчиков, немедленно получает ответ без тела и со статусом `503`.

Большинство клиентов отображают этот случай как ошибку. Например:

```go
m, err := nc.Request("foo", nil, time.Second);
# err == nats.ErrNoResponders
```
