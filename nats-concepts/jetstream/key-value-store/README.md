# Хранилище Key/Value

JetStream — слой персистентности NATS — обеспечивает не только более высокие уровни качества обслуживания и функции, связанные со «streaming», но и некоторые возможности, не характерные для систем обмена сообщениями.

Одна из таких возможностей — Key/Value store, позволяющая клиентским приложениям создавать `buckets` и использовать их как немедленно (а не eventually) консистентные, персистентные [ассоциативные массивы](https://en.wikipedia.org/wiki/Associative_array) (map). Обратите внимание, что это абстракция поверх функциональности Stream. Buckets материализуются как Streams (с именем, начинающимся на `KV_`). Всё, что можно сделать с bucket, можно сделать и со Stream, но при прямом использовании Stream вы получите больше функциональности, гибкости и контроля.

Обратите внимание: мы гарантируем немедленную консистентность для [monotonic writes](https://jepsen.io/consistency/models/monotonic-writes) и [monotonic reads](https://jepsen.io/consistency/models/monotonic-reads), но пока не гарантируем [read your writes](https://jepsen.io/consistency/models/read-your-writes), так как чтения через _direct get_ запросы могут обслуживаться followers или mirrors. Более согласованные результаты можно получить, отправляя get‑запросы лидеру потока, лежащего в основе Key/Value store.

* [Walkthrough](kv_walkthrough.md)
* [Подробности](../../../using-nats/developing-with-nats/js/kv.md)

## Управление Key/Value store

1. Создайте bucket, который соответствует потоку в базовом хранилище. Задайте лимиты KV/Stream по необходимости.
2. Используйте операции ниже.

## Операции в стиле map

KV buckets поддерживают типичные операции, которые ожидаются от немедленно консистентного key/value store:

* put: связать значение с ключом
* get: получить значение, связанное с ключом
* delete: очистить значение, связанное с ключом
* purge: очистить все значения, связанные со всеми ключами
* keys: получить копию всех ключей (с соответствующим значением или операцией)

## Атомарные операции для блокировок и контроля конкурентности

* create: связать значение с ключом только если по этому ключу сейчас нет значения (то есть compare‑to‑null и set)
* update: compare‑and‑set (aka compare‑and‑swap) значения по ключу

## Лимиты размера, TTL и т. д.

Можно задавать лимиты для buckets, например:

* максимальный размер bucket
* максимальный размер отдельного значения
* TTL: как долго store хранит значения

## Использование Key/Value store как потока сообщений

Наконец, можно делать вещи, которые обычно недоступны в Key/Value Store:

* watch: отслеживать изменения по ключу, что похоже на подписку (в смысле publish/subscribe) на ключ: watcher получает обновления от операций put или delete в реальном времени
* watch all: отслеживать все изменения по всем ключам bucket
* history: получать историю значений (и операций удаления) для каждого ключа во времени (по умолчанию история buckets равна 1, то есть хранится только последнее значение/операция)

## Примечания

Допустимый ключ может содержать следующие символы: `a-z`, `A-Z`, `0-9`, `_`, `-`, `.`, `=` и `/`, то есть это может быть список токенов, разделенных точками (значит, можно использовать wildcards для сопоставления иерархий ключей при наблюдении за bucket). Значение может быть любым массивом байт.
