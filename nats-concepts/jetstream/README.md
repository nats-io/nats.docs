# JetStream

В NATS есть встроенный движок персистентности под названием [JetStream](../../using-nats/jetstream/develop\_jetstream.md), который позволяет хранить сообщения и воспроизводить их позже. В отличие от _Core NATS_, где требуется активная подписка для обработки сообщений «по мере поступления», JetStream позволяет серверу NATS захватывать сообщения и воспроизводить их потребителям по необходимости. Эта функциональность обеспечивает другое качество обслуживания для сообщений NATS и позволяет строить отказоустойчивые и высокодоступные конфигурации.

JetStream встроен в `nats-server`. Если у вас есть кластер серверов с JetStream, вы можете включить репликацию данных и тем самым защититься от сбоев и прерываний обслуживания.

JetStream создан для решения проблем современных streaming‑технологий: сложности, хрупкости и недостатка масштабируемости. Некоторые технологии справляются с этим лучше других, но ни одна существующая streaming‑технология не является по‑настоящему мультиарендной, горизонтально масштабируемой или поддерживающей несколько моделей развертывания. Ни одна известная нам технология не может масштабироваться от edge до облака, используя тот же контекст безопасности и обеспечивая полную наблюдаемость развертывания для операций.

#### Дополнительные возможности JetStream

Слой персистентности JetStream открывает дополнительные сценарии использования, которые обычно не встречаются в системах обмена сообщениями. Построенные поверх JetStream, они наследуют его ключевые возможности: репликацию, безопасность, ограничения маршрутизации и зеркалирование.

* [Key Value Store](./#key-value-store) карта (ассоциативный массив) с атомарными операциями
* [Object Store](./#object-store) API для передачи, репликации и хранения файлов. Использует chunk‑передачи для масштабируемости.

Key/Value и передача файлов — возможности, часто встречающиеся в in‑memory базах данных или инструментах развертывания. NATS не стремится конкурировать с их функциональностью, но наша цель — предоставить разработчику разумно полный набор возможностей хранения данных и репликации для сценариев вроде микросервисов, edge‑развертываний и управления серверами.

#### Конфигурация

Чтобы настроить `nats-server` с JetStream, см.:

* [Настройка JetStream](../../running-a-nats-service/configuration/jetstream-config/resource\_management.md)
* [Кластеризация JetStream](../../running-a-nats-service/configuration/clustering/jetstream\_clustering/)

#### Примеры

Рабочие примеры кода JetStream см. в [NATS by Example](https://natsbyexample.com).

#### Цели

JetStream разрабатывался со следующими целями:

* Система должна быть простой в настройке и эксплуатации и быть наблюдаемой.
* Система должна быть безопасной и хорошо работать с моделями безопасности NATS 2.0.
* Система должна масштабироваться горизонтально и подходить для высокой скорости приема данных.
* Система должна поддерживать несколько сценариев использования.
* Система должна самовосстанавливаться.
* Система должна позволять сообщениям NATS быть частью потока по мере необходимости.
* Система должна быть агностичной к содержимому payload.
* Система не должна иметь сторонних зависимостей.

### Возможности JetStream

#### Streaming: временная развязка издателей и подписчиков

Одна из аксиом базовой модели publish/subscribe — наличие временной связности между издателями и подписчиками: подписчики получают сообщения только тогда, когда они активно подключены к системе обмена сообщениями (то есть они не получают сообщения, опубликованные в периоды, когда они не подписаны, не запущены или отключены). Традиционный способ обеспечить временную развязку — это 'durable subscriber' или иногда 'queues', но ни один из них не идеален:

* durable‑подписчики должны быть созданы _до_ публикации сообщений
* очереди предназначены для распределения и потребления нагрузки, а не для воспроизведения сообщений.

Однако во многих случаях вам не нужно «потребление ровно один раз», а нужна возможность воспроизведения сообщений по запросу столько раз, сколько нужно. Это и привело к популярности некоторых streaming‑платформ обмена сообщениями.

JetStream дает _оба_ варианта: возможность _потреблять_ сообщения по мере публикации (то есть 'queueing') и возможность _воспроизводить_ сообщения по запросу (то есть 'streaming'). См. [политики хранения](./#Retention-policies-and-limits) ниже.

**Политики воспроизведения**

JetStream consumers поддерживают несколько политик воспроизведения в зависимости от того, хочет ли приложение получить:

* _все_ сообщения, которые сейчас хранятся в потоке — то есть полный 'replay', при этом скорость воспроизведения может быть:
  * _instant_ (сообщения доставляются потребителю настолько быстро, насколько он способен их принимать).
  * _original_ (сообщения доставляются с той же скоростью, с какой они публиковались в поток; это полезно, например, для прогонки продакшн‑трафика на стейджинг).
* _последнее_ сообщение в потоке или _последнее сообщение по каждому subject_ (поскольку поток может захватывать более одного subject).
* начиная с конкретного _sequence number_.
* начиная с конкретного _start time_.

**Политики хранения и лимиты**

JetStream добавляет новые возможности и более высокое качество обслуживания поверх базовой функциональности Core NATS. Однако на практике потоки не могут расти «бесконечно», поэтому JetStream поддерживает несколько политик хранения и возможность задавать лимиты на потоки.

**Лимиты**

Вы можете установить следующие лимиты для потока:

* Максимальный возраст сообщения.
* Максимальный общий размер потока (в байтах).
* Максимальное количество сообщений в потоке.
* Максимальный размер отдельного сообщения.
* Лимит на количество consumers, которые могут быть определены для потока в любой момент времени.

Также необходимо выбрать **политику сброса (discard policy)**, которая определяет, что происходит, когда поток достигает одного из лимитов и публикуется новое сообщение:

* _discard old_ — поток автоматически удаляет самое старое сообщение, чтобы освободить место для новых.
* _discard new_ — новое сообщение отбрасывается (и вызов публикации JetStream возвращает ошибку, указывающую, что лимит достигнут).

**Политика хранения**

Для каждого потока можно выбрать тип хранения:

* _limits_ (по умолчанию) — обеспечивает воспроизведение сообщений в потоке.
* _work queue_ (поток используется как общая очередь, и сообщения удаляются по мере потребления) — обеспечивает потребление сообщений «ровно один раз».
* _interest_ (сообщения хранятся в потоке, пока есть consumers, которые еще не доставили сообщение) — вариант work queue, который сохраняет сообщения только при наличии интереса (consumers, определенных для subject сообщения).

Обратите внимание: независимо от выбранной политики хранения, лимиты (и политика сброса) _всегда_ применяются.

**Преобразования subject mapping**

JetStream также позволяет применять преобразования subject mapping к сообщениям при их попадании в поток.

#### Персистентное и консистентное распределенное хранилище

Вы можете выбрать долговечность и устойчивость хранения сообщений под свои потребности.

* Хранение в памяти.
* Хранение на диске.
* Репликация (1 (нет), 2, 3) между серверами NATS для отказоустойчивости.

JetStream использует оптимизированный для NATS распределенный кворумный алгоритм RAFT, чтобы распределять сервис персистентности между серверами NATS в кластере и сохранять немедленную консистентность (в отличие от [eventual consistency](https://en.wikipedia.org/wiki/Eventual\_consistency)) даже при сбоях.

Для записей (публикаций в поток) формальная модель консистентности NATS JetStream — [Linearizable](https://jepsen.io/consistency/models/linearizable). Для чтений (прослушивания или воспроизведения сообщений из потоков) формальные модели не вполне применимы, поскольку JetStream не поддерживает атомарное объединение нескольких операций (единственный вид «транзакции» — это персистентность, репликация и голосование одной операции над потоком). По сути JetStream [serializable](https://jepsen.io/consistency/models/serializable), так как сообщения добавляются в поток в едином глобальном порядке (который можно контролировать с помощью compare and publish).

Обратите внимание, что мы гарантируем немедленную консистентность для [monotonic writes](https://jepsen.io/consistency/models/monotonic-writes) и [monotonic reads](https://jepsen.io/consistency/models/monotonic-reads). Мы пока не гарантируем [read your writes](https://jepsen.io/consistency/models/read-your-writes), так как чтение через _direct get_ запросы может обслуживаться followers или mirrors. Более согласованные результаты можно получить, отправляя get‑запросы лидеру потока.

JetStream также может обеспечивать шифрование «на диске» для хранимых сообщений.

В JetStream конфигурация хранения сообщений определена отдельно от способов их потребления. Хранение описывается в [_Stream_](streams.md), а потребление сообщений — через несколько [_Consumers_](consumers.md).

**Коэффициент репликации потоков**

Коэффициент репликации потока (R, часто обозначаемый как число Replicas) определяет, в скольких местах он хранится, позволяя балансировать риск, использование ресурсов и производительность. Поток, который легко восстановить или который временный, может быть в памяти с R=1, а поток, который может пережить небольшой простой, может быть на диске с R=1.

Типичный вариант для работы при обычных сбоях и баланса производительности — поток на диске с R=3. Очень устойчивый, но менее производительный и более дорогой вариант — R=5, максимальный коэффициент репликации.

Вместо выбора максимума по умолчанию, мы рекомендуем выбирать оптимальный вариант в зависимости от сценария использования потока. Это оптимизирует ресурсы и повышает устойчивость системы в масштабе.

* Replicas=1 — не работает при сбое сервера, обслуживающего поток. Очень высокая производительность.
* Replicas=2 — на данный момент существенной пользы нет. Рекомендуем использовать Replicas=3.
* Replicas=3 — выдерживает потерю одного сервера, обслуживающего поток. Идеальный баланс между риском и производительностью.
* Replicas=4 — нет значимого преимущества по сравнению с Replicas=3, кроме небольшого выигрыша в кластере из 5 узлов.
* Replicas=5 — выдерживает одновременную потерю двух серверов, обслуживающих поток. Снижает риск ценой производительности.

**Зеркалирование и источники между потоками**

JetStream также позволяет администраторам легко зеркалировать потоки, например, между разными доменами JetStream для аварийного восстановления. Также можно определить поток, который «источником» использует один или несколько других потоков.

**Синхронизация данных на диск**

Потоки JetStream на диске сохраняют сообщения на диск. Однако, хотя JetStream синхронно сбрасывает записи файлов в ОС, при конфигурации по умолчанию он не выполняет немедленный `fsync` на диск. Сервер использует настраиваемый параметр `sync_interval` со значением по умолчанию 2 минуты, который определяет, как часто сервер делает `fsync` данных. Данные будут `fsync`‑нуты не позднее этого интервала. Это имеет важные последствия для надежности при сбоях ОС (то есть аварийном завершении ОС, например при отключении питания, а не только аварийном завершении или убийстве процесса `nats-server`):

В нереплицированной конфигурации сбой ОС может привести к потере данных. Клиент может опубликовать сообщение и получить подтверждение, но данные еще не были надежно записаны на диск. В результате после восстановления ОС сервер может потерять недавно подтвержденные сообщения.

В реплицированной конфигурации сообщение подтверждается после успешной репликации как минимум на кворум серверов. Однако одной репликации недостаточно, чтобы гарантировать максимальную устойчивость к множественным системным сбоям.
- Если несколько серверов одновременно выходят из строя из‑за сбоя ОС, и до того, как их данные были `fsync`‑нуты, кластер может не восстановить самые недавно подтвержденные сообщения.
- Если сбойный сервер потерял данные локально из‑за сбоя ОС (хотя это крайне редко), возможны комбинации событий, при которых он может снова войти в кластер и сформировать новое большинство с узлами, которые никогда не получали и не сохраняли конкретное сообщение. Тогда кластер может продолжить работу с неполными данными, и подтвержденные сообщения будут потеряны.

Уменьшение `sync_interval` увеличивает частоту записи на диск и уменьшает окно потенциальной потери данных, но снижает производительность. Кроме того, установка `sync_interval: always` гарантирует `fsync` после каждого сообщения до подтверждения. Эта настройка, в сочетании с репликацией в разных дата‑центрах или зонах доступности, обеспечивает самые сильные гарантии долговечности, но при самой низкой производительности.

Настройки по умолчанию выбраны так, чтобы сбалансировать производительность и риск потери данных в типичном продакшн‑сценарии развертывания в нескольких зонах доступности.

Например, рассмотрим поток с 3 репликами в трех отдельных зонах доступности. Чтобы состояние потока разошлось между узлами, требуется:
- Один из 3 серверов уже офлайн, изолирован или в partition.
- У второй машины происходит сбой ОС, из‑за которого теряются записи сообщений, которые были только на 2 из 3 узлов, потому что они не были `fsync`‑нуты.
- Лидер потока, входящий в эти 2 из 3 узлов, должен упасть или стать изолированным/в partition.
- Первый сервер из первоначального partition, который не получал записи, восстанавливается.
- Сбойный сервер ОС возвращается и связывается с первым сервером, но не с предыдущим лидером потока.

В итоге 2 из 3 узлов будут доступны, предыдущий лидер с записями будет недоступен, один сервер потеряет часть записей из‑за сбоя ОС, а один сервер никогда эти записи не видел из‑за предыдущего partition. Последние два сервера могут сформировать большинство и принять новые записи, фактически потеряв часть прежних записей.

Важно, что это сценарий, в котором состояние потока может разойтись, но в системе, развернутой в нескольких зонах доступности, потребуется, чтобы несколько отказов совпали очень точным образом.

Потенциальной мерой против такого отказа является не возвращать автоматически сервер после сбоя ОС, пока не станет известно, что большинство оставшихся серверов получили новые записи, или выполнить peer‑remove сбойного сервера, добавить его как нового очищенного peer и дать ему восстановиться по сети от здоровых узлов (что может быть дорого, в зависимости от объема данных).

Если минимизация потерь — абсолютный приоритет, `sync_interval: always` можно настроить, но учтите, что это влияет на производительность всего сервера и может ухудшить throughput или latency. Для продакшн‑сред операторам следует оценить, подходит ли конфигурация по умолчанию под их сценарий, целевую среду, стоимость и требования к производительности.

В качестве альтернативы можно использовать гибридный подход: существующие кластеры продолжают работать с настройками `sync_interval` по умолчанию, а добавляется новый кластер, настроенный с `sync_interval: always` и использующий server tags. Размещение потока можно указать так, чтобы этот поток хранил данные на более надежном кластере с помощью [placement tags](streams.md#placement).
```
# Configure a cluster that's dedicated to always sync writes.
server_tags: ["sync:always"]

jetstream {
    sync_interval: always
}
```

Создайте реплицированный поток, специально размещенный в кластере с `sync_interval: always`, чтобы обеспечить максимальную надежность только для тех записей потока, где это требуется.
```
nats stream add --replicas 3 --tag sync:always
```

#### Развязанный контроль потока

JetStream предоставляет развязанный контроль потока для потоков: это не end‑to‑end контроль, где издатель(и) ограничены скоростью самого медленного потребителя (то есть минимальным общим знаменателем). Вместо этого контроль потока происходит индивидуально между каждым клиентским приложением (издателем или потребителем) и сервером NATS.

При публикации в потоки через вызовы JetStream publish существует механизм подтверждений между издателем и сервером NATS, и вы можете выбирать синхронные или асинхронные (то есть «батчевые») публикации JetStream.

На стороне подписчиков отправка сообщений от сервера NATS к клиентским приложениям, получающим или потребляющим сообщения из потоков, также контролируется потоком.

#### Семантика exactly once

Поскольку публикации в потоки через JetStream publish подтверждаются сервером, базовое качество обслуживания потоков — '_at least once_'. Это означает, что хотя система надежная и обычно без дубликатов, существуют специфические сценарии сбоев, при которых приложение‑издатель может ошибочно считать, что сообщение не было опубликовано, и повторить публикацию, а также сценарии, при которых подтверждение потребления может потеряться, и сервер повторно отправит сообщение потребителю. Такие сценарии редки и сложны для воспроизведения, но они существуют и могут привести к воспринимаемой «дупликации» сообщений на уровне приложения.

Поэтому JetStream предлагает качество обслуживания '_exactly once_'. Для публикации это опирается на то, что приложение‑издатель добавляет уникальный ID сообщения или публикации в заголовок, а сервер отслеживает эти ID в течение настраиваемого скользящего периода времени, чтобы обнаружить повторную публикацию. Для подписчиков используется _двойной_ механизм подтверждений, чтобы избежать ошибочной повторной отправки сообщения подписчику после некоторых видов сбоев.

#### Consumers

JetStream [consumers](consumers.md) — это «представления» потока. Клиентские приложения подписываются на них (или тянут их), чтобы получать копии сообщений (или потреблять их, если поток настроен как рабочая очередь), хранящихся в потоке.

**Быстрые push‑consumers**

Клиентские приложения могут использовать быстрых `push` (упорядоченных) consumers без подтверждений, чтобы получать сообщения как можно быстрее (в рамках выбранной политики воспроизведения) на заданный subject доставки или в inbox. Эти consumers предназначены для «воспроизведения», а не для «потребления» сообщений потока.

**Горизонтально масштабируемые pull‑consumers с батчингом**

Клиентские приложения также могут использовать и разделять `pull` consumers, которые работают по спросу, поддерживают батчи и требуют явного подтверждения получения и обработки сообщений. Это означает, что их можно использовать как для потребления (то есть для использования потока как распределенной очереди), так и для обработки сообщений в потоке.

Pull consumers могут и должны разделяться между приложениями (как queue‑groups), чтобы обеспечить простую и прозрачную горизонтальную масштабируемость обработки или потребления сообщений в потоке без необходимости, например, определять партиции или беспокоиться об отказоустойчивости.

Примечание: использование pull consumers не означает, что вы не можете получать обновления (новые сообщения, опубликованные в поток) «пушем» в реальном времени. Вы можете задать (разумный) таймаут для вызова Fetch и вызывать его в цикле.

**Подтверждения consumers**

Хотя можно выбрать consumers без подтверждений, обменивая качество обслуживания на максимально быструю доставку, большая часть обработки не является идемпотентной и требует более высокого качества обслуживания (например, способности автоматически восстанавливаться после разных сценариев отказов, при которых некоторые сообщения могут не быть обработаны или быть обработаны больше одного раза). В таких случаях лучше использовать consumers с подтверждениями. JetStream поддерживает несколько видов подтверждений:

* Некоторые consumers поддерживают подтверждение _всех_ сообщений вплоть до номера последовательности подтверждаемого сообщения; другие consumers обеспечивают высочайшее качество обслуживания, но требуют явного подтверждения получения и обработки каждого сообщения, а также задают максимальное время ожидания подтверждения сервером для конкретного сообщения перед повторной доставкой (в другой процесс, подключенный к consumer).
* Вы также можете отправлять _отрицательные_ подтверждения.
* Можно отправлять подтверждения _in progress_ (чтобы показать, что сообщение все еще обрабатывается и нужно больше времени до ack или nack).

### Хранилище ключ‑значение

Слой персистентности JetStream предоставляет хранилище ключ‑значение: возможность хранить, извлекать и удалять сообщения‑`value`, связанные с `key`, в рамках `bucket`.

* [Концепции](key-value-store/)
* [Пошаговое руководство](key-value-store/kv\_walkthrough.md)
* [API и детали](../../using-nats/developing-with-nats/js/kv.md)

#### Наблюдение и история

Вы можете подписываться на изменения в Key Value на уровне bucket или отдельного ключа с помощью `watch` и при необходимости получать `history` значений (и удалений), которые происходили по конкретному ключу.

#### Атомарные обновления и блокировки

Хранилище ключ‑значение поддерживает атомарные операции `create` и `update`. Это позволяет реализовать пессимистические блокировки (создав ключ и удерживая его) и оптимистические блокировки (используя CAS — compare and set).

### Хранилище объектов

Хранилище объектов похоже на хранилище ключ‑значение. Ключ заменяется именем файла, а значение предназначено для хранения произвольно больших `objects` (например, файлов, даже очень больших), а не «значений» размером с сообщение (по умолчанию ограничено 1 МБ). Это достигается разбиением сообщений на части.

* [Концепции](object-store/obj\_store.md)
* [Пошаговое руководство](object-store/obj\_walkthrough.md)
* [API и детали](../../using-nats/developing-with-nats/js/object.md)

## Legacy

Note that JetStream completely replaces the [STAN](../../legacy/stan/) legacy NATS streaming layer.
