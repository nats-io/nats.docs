# NATS 2.11

Гид рассчитан на пользователей NATS, обновляющихся с версий v2.10.x. Представлен краткий обзор возможностей с ссылками на подробную документацию.

## Возможности

### Наблюдаемость

- **Распределённый трекинг сообщений:** теперь можно отслеживать, как сообщение проходит систему — задайте заголовок `Nats-Trace-Dest` с inbox-subject. Серверы по пути отправляют события на указанный subject, сообщающие когда сообщение приходит/уходит, по какому типу соединения, при маппинге subject-ов и при пересечении границ import/export аккаунтов. Заголовок `Nats-Trace-Only` при значении `true` позволяет распространять трейс-события по subject-у без доставки их подписчикам.

### Потоки

- **TTL для отдельных сообщений:** можно задавать `Nats-TTL` в строковом или числовом (секунды) формате, чтобы отдельные сообщения устаревали независимо от глобальных ограничений потока. Работает вместе с другими лимитами. Подробнее — в [ADR-43](https://github.com/nats-io/nats-architecture-and-design/blob/main/adr/ADR-43.md).
- **Маркеры удаления subject-ов при `MaxAge`:** опция `SubjectDeleteMarkerTTL` добавляет сообщения-маркеры удаления при полном удалении последнего сообщения subject-а по `MaxAge`. Маркеры содержат заголовок `Nats-Marker-Reason` с причиной удаления.
- **Ограничение скорости поступления:** параметры `max_buffered_size` и `max_buffered_msgs` в блоке `jetstream` позволяют ограничить скорость публикаций Core NATS в JetStream, защищая систему от перегрузки.

### Потребители

- **Приоритетные группы Pull-потребителей:** теперь можно назначать приоритетные группы с pinning и overflow, управлять фейловером и приоритетом для нескольких клиентов, читающих из одного потребителя. Политики основаны на количестве ожидающих сообщений или неподтверждений, позволяя гибко переключать нагрузку или учитывать региональные сценарии.
- **Приостановка потребителей:** доставку можно временно приостановить через новый API endpoint `pause` (или `PauseUntil` при конфигурации), удобно для обслуживания и миграций. После окончания паузы доставка возобновляется автоматически, при этом клиенты всё ещё получают heartbeat, чтобы не срабатывали ошибки.

### Операционные улучшения

- **Репликационный трафик в аккаунтах с ассетами:** трафик Raft можно отправлять в тот же аккаунт, где живут ассеты, а не через системный аккаунт — это задаётся свойством `cluster_traffic` в настройках JetStream-аккаунта. В связке с несколькими маршрутизаторами это снижает задержки и предотвращает head-of-line блокировки в сильно загруженных мульти-арендных или мульти-аккаунтных сетапах.
- **TLS первым на leafnode:** опция `handshake_first` внутри `tls` leafnode позволяет сначала выполнять TLS-handshake, прежде чем идти дальше по протоколу.
- **Хэш состояния конфигурации:** новая опция `-t` для бинарника генерирует хэш конфигурационного файла. Поле `config_digest` в `/varz` показывает текущий хэш, позволяя проверять, изменилась ли конфигурация на диске по отношению к запущенной.
- **Шифрование TPM на Windows:** в Windows ключи файлового хранилища теперь можно хранить в TPM — полезно в средах с риском физического доступа.

### MQTT

- **SparkplugB:** встроенная поддержка MQTT теперь соответствует SparkplugB, включая `NBIRTH` и `NDEATH`.

## Улучшения

- **Реплицированные предложения удаления:** удаления сообщений в потоках с interest или workqueue теперь реплицируются через Raft, чтобы гарантировать одинаковый порядок удаления на всех репликах и снизить риск рассинхронизации после отказов.
- **Метаслой, поток и согласованность потребителей:** новый лидер отвечает на запросы только после синхронизации Raft-лога, что защищает от рассинхронизации KV-обновлений и потока при смене лидера.
- **Надёжность реплицированных потребителей:** после смены лидера такие потребители теперь стабильно повторно доставляют неподтверждённые сообщения.
- **Начальная последовательность потребителей:** теперь всегда соблюдается значение `StartSeq`, кроме внутренних скрытых потребителей источников/зеркал.

## Предостережения при обновлении

#### Ограничение скорости поступления

Сервер может возвращать ошибку 429 с типом `JSStreamTooManyRequests`, если очередь на поток переполнена. Обычно этого не происходит при публикации через JetStream с ожиданием PubAck, но может случаться при отправке через Core NATS без ожидания PubAck, что не рекомендуется.

Параметры `max_buffered_size` и `max_buffered_msgs` определяют, сколько сообщений можно поставить в очередь до ограничения. При необходимости увеличьте их. Значения по умолчанию — 128МБ и 10 000 записей (в v2.10 — без ограничений).

В логах это выглядит так:

```
[WRN] Dropping messages due to excessive stream ingest rate on 'account' > 'my-stream': IPQ len limit reached
```

Если появляются такие предупреждения, сначала попробуйте поднять лимиты, одновременно исследуя быстрых издателей. Например:

```
jetstream {
  max_buffered_msgs: 50000
  max_buffered_size: 256mib
}
```

#### Реплицированные предложения удаления

Поскольку удаления теперь реплицируются через proposals, немного возрастает репликационный трафик.

#### Проверка здоровья JetStream

`js-server-only` healthcheck больше не проверяет металида на v2.11.0. До этого при перезапуске сервер мог считаться unhealthy из-за проверки металида. Теперь проблема устранена. Если нужна старая логика v2.10, есть новый healthcheck `js-meta-only` для проверки мета-группы.

#### Код возврата

Ранее NATS Server при graceful shutdown (например, SIGTERM) завершался с кодом 1. С v2.11 возвращается код 0.

#### Имена сервера, кластера и gateway

Имена серверов, кластеров и gateway с пробелами теперь недопустимы — такие конфигурации не запускаются, потому что нарушают протокол. Убедитесь, что пробелов нет.

## Предостережения при откате

#### Состояние потока

При откате с v2.11 до v2.10 файлы состояния потока пересобираются из-за изменения формата. Требуется повторное сканирование всех блоков, что может временно увеличить CPU и время возвращения узла в состояние healthy. Случается только при первом запуске после отката и не приводит к потере данных.
