# NATS 2.12

Этот гид предназначен для существующих пользователей NATS, которые обновляются с версий v2.11.x. Здесь кратко описаны новые возможности и приведены ссылки на подробную документацию по каждому улучшению.

## Возможности

### Потоки

- **Атомарная публикация пакета:** опция конфигурации потока `AllowAtomicPublish` позволяет атомарно публиковать N сообщений в один поток. Работает как для реплицированных, так и для нереплицированных потоков, включая проверку согласованности каждого сообщения до внесения пакета. Подробнее — в [ADR-50](https://github.com/nats-io/nats-architecture-and-design/blob/main/adr/ADR-50.md).
- **Распределённый счетчик (CRDT):** `AllowMsgCounter` добавляет семантику увеличения/уменьшения значения потока. Такие потоки можно зеркалировать или агрегировать через mirroring и sourcing. Подробнее — в [ADR-49](https://github.com/nats-io/nats-architecture-and-design/blob/main/adr/ADR-49.md).
- **Планирование отложенных сообщений:** опция `AllowMsgSchedules` позволяет планировать публикацию сообщений с задержкой. Подробнее — в [ADR-51](https://github.com/nats-io/nats-architecture-and-design/blob/main/adr/ADR-51.md).

### Потребители

- **Политика приоритизации Pull-потребителей:** к существующему набору политик (overflow, pinning) добавлена политика `prioritized`. В отличие от overflow-политики, она позволяет потребителю получать сообщения раньше, но из-за этого нагрузка может временно перепрыгивать между клиентами. Подробнее — в [ADR-42](https://github.com/nats-io/nats-architecture-and-design/blob/main/adr/ADR-42.md#prioritized-policy).

### Операционные улучшения

- **Метаданные сервера:** помимо `server_tags`, содержащих теги сервера, появился `server_metadata` — map с ключами и значениями, описывающими дополнительные метаданные.
- **Повышение зеркал:** поток, который синхронизируется зеркалами, теперь можно продвинуть до роли основного, что открывает новые подходы к аварийному восстановлению. Перед продвижением необходимо удалить текущий основной поток или убрать у него связанные subject-ы, а затем разрешить продвинутому зеркалу слушать эти subject-ы.
- **Экспоненциальный бэкофф для маршрутов и gateway:** маршруты кластера и gateway могут использовать экспоненциальный бэкофф при повторных попытках соединения через `connect_backoff`. При значении `true` бэкофф стартует с 1 секунды и достигает 30 секунд. Это замедляет переконнекшен, но существенно снижает количество DNS-запросов и попыток соединения при перезапуске серверов или простоях.
- **Оффлайн-ассеты:** при понижении версии сервер теперь понимает, что задействованы новые функции, и переводит поток и/или потребителя в unsupported/offline режим. Подробнее см. раздел с предостережениями при даунгрейде и [ADR-44](https://github.com/nats-io/nats-architecture-and-design/blob/main/adr/ADR-44.md#offline-assets).
- **Защита масштабирования и сброса потока/потребителя:** сервер лучше защищается от выборов лидера, когда состояние пустое, что повышает стабильность реплицированных in-memory потоков. Обычно для quorum требуется несколько серверов с данными, но теперь можно перезапустить всех кроме одного, и данные in-memory потока восстановятся. При этом все реплицирующие серверы должны быть доступны, а не только те, что в кворме. Это даёт серверам возможность выбрать стратегию, сохраняющую все данные.

## Улучшения

- **Асинхронная запись реплицированных потоков:** данные теперь асинхронно записываются на диск, что даёт заметный прирост производительности. При этом они по-прежнему последовательно фиксируются в Raft-логе до коммита, поэтому консистентность не страдает.
- **Эластичные указатели в файловых потоках:** потоки, основанные на файловом хранилище, используют эластичные указатели для write-through кэшей. Это позволяет серверу реагировать на сбор мусора и преждевременно освобождать кэши, чтобы избежать ошибок OOM (см. раздел про обновление).
- **Использование cipher suite из `crypto/tls`:** автоматически добавляются новые наборы шифров. Наиболее небезопасные по умолчанию отключены, но их можно включить при включении `allow_insecure_cipher_suites`.
- **Системные события для аккаунта `$G`:** глобальный аккаунт теперь тоже публикует события (подключения/отключения).
- **`GOMAXPROCS` и `GOMEMLIMIT` в статистике сервера:** статистика теперь включает эффективные лимиты Go по CPU и памяти.
- **Новые преобразования subject-ов:** функции `partition(n)` и `random(n)` создают номер партиции или случайное число до `n`, основываясь на всём subject-е, а не на токенах по индексам как `partition(n, …)`.
- **Логирование имени аккаунта и пользователя:** любые сообщения, связанные с клиентской сессией (например, превышение лимита соединений или ошибки аутентификации), теперь содержат аккаунт и пользователя.
- **Улучшения логирования:** также лог закрытия соединения теперь включает имя удалённого сервера.
- **Свойство «изолированные leaf node»:** в крупных развертываниях east-west трафик от leaf node может быть лишним, если они не нуждаются в прямом обмене. Вместо трюка с одинаковым `cluster_name` используется свойство `isolate_leafnode_interest`.
- **Отключение leaf node через перезагрузку конфигурации:** при `disabled: true` leaf node отключается по reload. Если поменять `false` → `true`, то подключённый leaf node отключается и не переподключается; если наоборот — его снова попросят подключиться.

## Предостережения при обновлении

#### Использование памяти

С появлением эластичных указателей в файловом хранилище наблюдается новая модель использования памяти. В одних системах RSS может уменьшиться, в других — увеличиться, в зависимости от количества ассетов и шаблонов публикаций.

Сервер впервые умеет реагировать на стресс по памяти, принудительно очищая кэши файлов по необходимости и отдавая память ОС. Это снижает риски OOM, но также позволяет сохранять кэши дольше, если ресурсы доступны, чтобы ускорить чтение.

Поведение регулируется порогами GC, определяемыми переменной окружения `GOMEMLIMIT`. Настройте значение под доступную память или под резервы в Kubernetes.

#### Жёсткий JetStream API

С версии v2.11 сервер под капотом начинал логировать предупреждение, если был получен некорректный JetStream-запрос:

```
[WRN] Invalid JetStream request '$G > $JS.API.STREAM.CREATE.test-stream': json: unknown field "unknown"
```

С v2.12 сервер не только логирует, но и отбрасывает такой запрос, поскольку strict mode включён по умолчанию. Значит, неправильные JetStream-запросы теперь отклоняются.

Если появляется вышеприведённое сообщение, убедитесь, что приложение и клиентские библиотеки отправляют допустимые обращения. Если нужно — временно отключите строгий режим:

```
jetstream {
  strict: false
}
```

## Предостережения при откате

#### Состояние потока

При откате с v2.12 до v2.11 файлы состояния потока пересобираются из-за изменения формата в v2.12. Это приводит к повторному сканированию всех блоков сообщений, может потребовать больше CPU и увеличить время поднимки узла. Это случается только один раз после отката и не теряет данные.

При откате нужно использовать версию не ниже v2.11.9. С этой версии сервер распознаёт новые функции v2.12 и переводит соответствующие потоки/потребителей в unsupported/offline режим. Это защищает и данные, и сам сервер от обращения к неподдерживаемым функциям.
