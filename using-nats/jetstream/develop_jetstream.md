# Разработка с JetStream

## Решение использовать стриминг и более высокие качества обслуживания

В современных системах приложения могут предоставлять сервисы или производить и потреблять потоки данных. Базовый аспект publish-subscribe — временная связность: подписчики должны быть запущены, чтобы получить сообщение в момент публикации. В общем случае, если требуется наблюдаемость, приложения должны потреблять сообщения в будущем, потреблять их в своём темпе или получать все сообщения, то стриминговые возможности JetStream обеспечивают временную развязку между издателями и потребителями.

Использование стриминга и связанных с ним более высоких качеств обслуживания — это наиболее затратная по вычислениям и хранению часть обмена сообщениями.

### Когда использовать стриминг

Стриминг идеален, когда:

* Производители и потребители данных сильно развязаны. Они могут быть онлайн в разное время, и потребители должны получать сообщения.

* Нужна историческая запись данных в stream. Это ситуация, когда потребителю нужен replay данных.

* Для инициализации требуется последнее сообщение в stream, а производитель может быть офлайн.

* Нет априорного знания о потребителях, но они должны получать сообщения. Это часто ошибочное предположение.

* Данные в сообщениях живут дольше, чем предполагаемая жизнь приложения.

* Приложения должны потреблять данные в своём темпе.

* Нужен развязанный контроль потока между издателями и потребителями stream.

* Требуется качество обслуживания «ровно один раз» с дедупликацией публикаций и двойными подтверждениями потребления.

Обратите внимание: нельзя делать предположений о том, кто будет получать и обрабатывать данные в будущем, и с какой целью.

### Когда использовать Core NATS

Core NATS идеален как быстрый путь запросов для масштабируемых сервисов, где допускается потеря сообщений или когда приложения сами обеспечивают гарантии доставки.

Сюда относятся:

* Сервисные паттерны с тесно связанным request-reply
    * Отправляется запрос, и приложение обрабатывает ошибки по таймауту

      (повторы, ошибки и т. д.). __Полагаться здесь на то, что система сообщений выполнит повторную отправку, считается анти‑паттерном.__
* Где важно только последнее полученное сообщение, а новые сообщения приходят достаточно часто, чтобы приложение могло терпеть потерю. Это может быть поток котировок, частый обмен сообщениями в control plane сервиса или телеметрия устройств.

* Сообщения с низким TTL, когда ценность данных быстро деградирует или истекает.

* Ожидаемый набор потребителей известен заранее, и потребители должны быть в сети. Здесь хорошо работает request-reply или потребители могут отправлять подтверждения на уровне приложения.

* Control plane сообщения.

## Обзор функциональности JetStream

### Streams
  * Можно использовать `Add Stream`, чтобы идемпотентно определять streams и их атрибуты (исходные subjects, политики retention и хранения, лимиты)
  * Можно использовать `Purge` для очистки сообщений в stream
  * Можно использовать `Delete` для удаления stream


### Публикация в stream

Есть совместимость между Core NATS и JetStream в том смысле, что streams слушают сообщения Core NATS. _Однако_ вы заметите, что в JetStream вызовах клиентских библиотек есть свои `Publish`‑вызовы, и может возникнуть вопрос, в чём разница между `Core NATS Publish` и `JetStream Publish`.

Да, когда приложение Core NATS публикует сообщение на subject stream, сообщение будет сохранено в stream, но это не цель, поскольку вы публикуете с более низким качеством обслуживания Core NATS. Так что, хотя использовать Core NATS Publish для публикации в stream технически возможно, рассматривайте это скорее как удобство для облегчения миграции приложений на стриминг, а не как желаемое конечное состояние или идеальный дизайн.

Вместо этого лучше использовать JetStream Publish (которые всё равно получат подписчики Core NATS, не использующие streams), потому что:

* JetStream публикации подтверждаются серверами с JetStream, что обеспечивает более высокие качества обслуживания
    * Если издатель получает подтверждение от сервера, он может безопасно удалить любое состояние, связанное с публикацией: сообщение не только правильно принято сервером, но и успешно сохранено.
    * Независимо от того, используете ли вы синхронные или асинхронные JetStream публикации, между издателем и инфраструктурой JetStream подразумевается контроль потока.
    * Можно получить качество обслуживания «ровно один раз», вставляя уникальный ID публикации в заголовок сообщения.

#### См. также
* [Синхронная и асинхронная публикация JetStream в Java](https://nats.io/blog/sync-async-publish-java-client/#synchronous-and-asynchronous-publishing-with-the-nats-java-library)

### Создание consumer

[Consumers](../../nats-concepts/jetstream/consumers.md) — это «представления» stream с собственным курсором. Через них клиентские приложения получают сообщения из stream (то есть «replay») для обработки или потребления. Consumers могут фильтровать сообщения по `filtering subject` и определять, какая часть stream воспроизводится, согласно `replay policy`.

Вы можете создавать *push* или *pull* consumers:
* *Push* consumers (в частности упорядоченные push consumers) — лучший способ получить собственную полную копию выбранных сообщений в stream.
* *Pull* consumers — лучший способ горизонтально масштабировать обработку (или потребление) выбранных сообщений в stream, используя несколько клиентских приложений, разделяющих один pull consumer, и позволяя обрабатывать сообщения пачками.

Consumers могут быть ephemeral или durable и поддерживают разные политики подтверждений: none, этот номер последовательности, этот номер и все предыдущие.

#### Replay policy

Вы выбираете, какие сообщения из stream доставлять вашему consumer:
* все
* начиная с номера последовательности
* начиная с момента времени
* последнее сообщение
* последние сообщения для всех subject в stream

И вы можете выбрать скорость воспроизведения: мгновенно или с темпом, соответствующим исходной скорости публикации в stream.

### Подписка из consumer

Клиентские приложения «подписываются» из consumers через JetStream вызовы Subscribe, QueueSubscribe или PullSubscribe (и вариации). Обратите внимание: с момента первого релиза JetStream клиенты разработали более эргономичный API для работы с [Consumers](https://github.com/nats-io/nats.go/blob/main/jetstream/README.md#consumers) при обработке сообщений.

#### Подтверждение сообщений

Некоторые consumers требуют, чтобы код клиентского приложения подтверждал обработку или потребление сообщения, но способов подтверждения (или отказа) больше одного:

* `Ack` — подтверждает, что сообщение полностью обработано
* `Nak` — сигнализирует, что сообщение сейчас не будет обработано, и можно перейти к следующему; NAK‑сообщение будет повторно доставлено
* `InProgress` — отправляется до истечения AckWait и указывает, что работа продолжается и период следует продлить ещё на `AckWait`
* `Term` — инструктирует сервер прекратить повторную доставку сообщения, не считая его успешно обработанным

#### См. также
* Java
  * [JetStream Java tutorial](https://nats.io/blog/hello-world-java-client/)
  * [Создание stream в JetStream на Java](https://nats.io/blog/jetstream-java-client-01-stream-create/)
  * [Публикация в JetStream на Java](https://nats.io/blog/jetstream-java-client-02-publish/)
  * [Consumers на Java](https://nats.io/blog/jetstream-java-client-03-consume/)
  * [Push consumers на Java](https://nats.io/blog/jetstream-java-client-04-push-subscribe/#jetstream-push-consumers-with-the-natsio-java-library)
  * [Pull consumers на Java](https://nats.io/blog/jetstream-java-client-05-pull-subscribe/#jetstream-pull-consumers-with-the-natsio-java-library)
