# Концепции JetStream

## Функциональности, предоставляемые JetStream

JetSteam — встроенная в NATS распределённая подсистема персистентности. Она добавляет новые возможности и более высокие качества обслуживания поверх базовой функциональности Core NATS.

### Временная развязка

В современных системах приложения могут предоставлять сервисы или производить и потреблять потоки данных, используя publish-subscribe системы обмена сообщениями, такие как NATS.

Базовый аспект publish-subscribe — временная связность: подписчики должны быть запущены, чтобы получить сообщение в момент публикации. В общем случае, если требуется наблюдаемость, приложения должны потреблять сообщения в будущем, потреблять их в своём темпе или получать все сообщения, то стриминговые возможности JetStream обеспечивают временную развязку между издателями и потребителями.

### Очереди и replay

JetStream обеспечивает возможность ставить сообщения в очередь для будущего потребления и повторно воспроизводить (replay) сообщения. Streams можно настраивать либо на очередь сообщений для будущего потребления consumer'ами с политикой retention `WorkingQueue` (в этом случае сообщения удаляются из stream по мере потребления), либо consumer'ы могут быть настроены с политикой retention `Limits`, чтобы обеспечивать по запросу индивидуальный или распределённый replay сообщений с начала stream или с определённого момента времени.

### Mirroring и Sourcing

JetStream позволяет зеркалировать сообщения из одного stream в другой и «источить» (source) сообщения из одного stream в другой. Это даёт возможность строить сложные топологии streams и consumers.

Например, можно иметь исходный stream, который хранит сообщения только ограниченное время и используется для replay, и который также может подпитывать любое количество других streams, настроенных для потребления сообщений в очереди и зеркалирующих или источающих из этого исходного stream. Это позволяет consumer'ам потреблять из зеркального/источенного stream, не влияя на исходный stream, и в своём темпе.

### Более высокие качества обслуживания

Помимо временной развязки издателей и подписчиков (то есть «стриминга»), JetStream предоставляет и другие возможности и качества обслуживания.

#### Гарантированная доставка

Базовое качество обслуживания Core NATS — это *«не более одного раза»* (at most once) доставка сообщений. Это означает, что хотя для коммуникации между серверами и клиентами (и между серверами в кластерах) используется надёжный транспорт (TCP) для восстановления после «случайных» сетевых сбоев (например, потери пакетов), качество обслуживания не является «гарантированным»: есть сценарии сбоев, при которых клиентские приложения могут столкнуться с потерей сообщений, в частности:
* Отключения:
Если клиентское приложение испытывает сетевой сбой, достаточный для того, чтобы TCP‑соединение с сервером было разорвано или сброшено, оно может не получить часть сообщений, буферизованных (или опубликованных) во время сбоя.
* Медленные потребители
Инфраструктура NATS спроектирована так, чтобы «защищать себя» от «плохих клиентов». Если клиентское приложение, подписанное на сообщения, не успевает за потоком публикаций по subject (то есть является «медленным потребителем»), nats-server будет пытаться буферизовать сообщения для доставки, но ресурсы не бесконечны, и для защиты от исчерпания памяти (включая буферы для подключённых клиентов) у буферов есть лимиты. Когда лимит буфера клиента достигнут, nats-server «сбрасывает» соединение с этим клиентом и очищает буфер.

Хотя nats-server логирует сообщение «slow consumer» при отключении клиента, с точки зрения клиентского приложения это выглядит как временное отключение от сервера, и некоторые сообщения могут так и не быть получены.

JetStream предлагает «гарантированное» качество обслуживания за счёт различных подтверждений (и для издателей, и для подписчиков), которые обеспечивают два уровня качества обслуживания сверх базового «at most once» Core NATS:
* *«как минимум один раз»* (at least once): использование подтверждённых публикаций JetStream и подтверждённых consumers гарантирует получение всех сообщений без потерь из‑за сбоев, остановок приложений или медленного потребления. Это называется «как минимум один раз», потому что остаются редкие сценарии сбоев, при которых некоторые сообщения могут быть получены более одного раза (что не проблема при идемпотентной обработке).
* *«ровно один раз»* (exactly once): дополнительно к вышеописанному сервер выполняет дедупликацию сообщений на стороне издателя и предотвращает повторное получение сообщений приложением‑потребителем при восстановлении после некоторых сбоев, используя «двойные подтверждения».

Оба эти качества обслуживания означают, что клиентские приложения автоматически восстанавливаются после отключения от nats-server без потери сообщений (при использовании durable consumers приложения могут даже остановиться и позже перезапуститься). Для «медленных потребителей» использование stream означает, что «буферизация» сообщений происходит в stream (который может быть гораздо больше серверного буфера), а не в серверном буфере.

### Управление потоком

Самый очевидный способ избежать «медленных потребителей» — реализовать некоторую форму управления потоком. Хотя TCP предоставляет встроенную форму управления потоком для сетевых коммуникаций, она напрямую не применима к publish-subscribe системам, потому что TCP — это точка‑точка («1 к 1»), а publish-subscribe допускает «1 к N» (и «N к M») коммуникации.

Если реализовывать управление потоком для базового Core NATS publish-subscribe, пришлось бы делать «end-to-end» управление потоком (между издателем и всеми текущими подписчиками). В итоге вы ограничивали бы издателей по _наименьшему общему знаменателю_ всех подписчиков — издатель(и) замедлялись бы до скорости _самого медленного_ подписчика.
Из‑за этого эффекта и потому что один из ключевых сценариев publish-subscribe — распространение *данных в реальном времени*, Core NATS _не_ реализует end-to-end управление потоком.

Хотя вы можете реализовать собственную end-to-end схему на Core NATS, используя request-reply, проще (и лучше) использовать JetStream и его *развязанный* контроль потока.

Контроль потока в JetStream *развязан*, потому что он не «end-to-end», а независим между клиентским приложением‑издателем JetStream и stream (то есть JetStream‑включёнными nats-server'ами), а также между stream и клиентскими приложениями, использующими JetStream consumers.

## Хранение

В JetStream конфигурация хранения сообщений задаётся отдельно от их потребления. Хранение определяется в _Stream_, а потребление сообщений — несколькими _Consumers_.
