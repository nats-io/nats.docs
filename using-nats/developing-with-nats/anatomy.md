# Для чего использовать NATS?

Вы можете использовать NATS для обмена информацией и отправки запросов другим приложениям. Также с помощью NATS можно превратить ваше приложение в распределённое одноранговое приложение.

На высоком уровне ваше приложение может использовать NATS для:

1. Отправки (Publish) информации другим приложениям или экземплярам вашего приложения.
2. Получения (Subscribe) информации (в реальном времени или при запуске приложения) от других приложений или экземпляров вашего приложения.
3. Отправки запроса серверу или сервису, предоставляемому другим приложением.
4. Хранения общего (согласованного) состояния/данных между другими приложениями или экземплярами вашего приложения.
5. Получения информации в реальном времени о новых данных или изменениях общего состояния/данных.

Использование NATS означает, что разработчику приложения не нужно беспокоиться о следующем:

* Кто отправляет информацию, которую вы хотите получить.
* Кто заинтересован в информации, которую вы отправляете другим, сколько их и где они находятся.
* Где расположен сервис, которому вы отправляете запрос, и сколько у него активных экземпляров.
* Сколько разделов или серверов в кластере.
* Безопасность (просто идентифицируйте себя).
* Работает ли ваше приложение в момент отправки информации (используя JetStream).
* Управление потоком (используя JetStream).
* Более высокие качества обслуживания, такие как **ровно один раз** (используя JetStream).
* Отказоустойчивость и какие серверы сейчас доступны.
* Топология инфраструктуры серверов NATS и её архитектура.

# Анатомия клиентского приложения NATS

Клиентское приложение NATS будет использовать клиентскую библиотеку NATS следующим образом:

Во время инициализации оно сначала подключится (при необходимости безопасно) к инфраструктуре сервиса NATS (то есть к одному из серверов NATS).

После успешного подключения приложение будет:
  * Создавать сообщения и публиковать их в subject или streams.
  * Подписываться на subject(ы) или consumer'ы stream для получения сообщений от других процессов.
  * Публиковать запросы сервису и получать ответные сообщения.
  * Получать запросы и отправлять ответы или подтверждения (ack).
  * Связывать и получать сообщения, связанные с ключами в KV bucket.
  * Сохранять и получать произвольные большие бинарные данные с ключами в Object Store.
 
Наконец, при завершении работы приложение должно отключиться от инфраструктуры сервиса NATS.

См. следующие разделы, чтобы узнать больше об этих действиях.

# Подключение и отключение

Первое, что нужно сделать приложению, — подключиться к NATS. В зависимости от конфигурации используемой инфраструктуры сервиса NATS, соединение может требовать безопасности, поэтому приложению нужно уметь указывать учётные данные безопасности при подключении. Приложение может создавать столько подключений NATS, сколько нужно (каждое соединение полностью независимое; например, можно подключиться дважды как разные пользователи), хотя обычно большинство приложений делает одно подключение.

Получив валидное соединение, вы можете использовать его в приложении для всех функций Core NATS, таких как подписка на subject, публикация сообщений, выполнение запросов (и получение JetStream-контекста).

В конце приложение должно корректно отключиться от NATS.

## [Подключение к NATS](connecting/README.md)

## Мониторинг подключения к NATS

Рекомендуется использовать [слушатели событий подключения](events/events.md), чтобы получать уведомления и вести лог при подключениях, переподключениях или отключениях. Обратите внимание: при отключении от процесса сервера NATS клиентская библиотека автоматически попытается [переподключиться](reconnect/README.md) к одному из других серверов NATS в кластере. Вы также всегда можете проверить [текущий статус подключения](events/README.md).

## Безопасное отключение от NATS

Рекомендуемый способ отключения — использовать [Drain()](receiving/drain.md), который дождётся завершения текущей обработки и корректно всё очистит. Если же нужно закрыть соединение сразу, используйте `close()` у объекта подключения.

# Работа с сообщениями

Сообщения хранят данные, которыми обмениваются приложения. Сообщение имеет *subject*, *payload* данных (массив байт), и может иметь поля *reply-to* и *header*.

Вы получаете сообщения через подписки или запросы. Операции публикации (и запроса) обычно принимают subject и payload (массив байт) и сами создают сообщение, но при необходимости можно создать сообщение самостоятельно (например, чтобы установить заголовки).

Некоторые сообщения можно «подтверждать» (например, сообщения, полученные от pull consumer в JetStream), и существуют разные формы подтверждений (включая отрицательные подтверждения, а также подтверждения, показывающие, что ваше приложение получило сообщение, но ему нужно больше времени на обработку).

### Структурированные данные

Некоторые библиотеки позволяют легко [отправлять](sending/structure.md) и [получать](receiving/structure.md) структурированные данные.

# Использование Core NATS

После успешного подключения к инфраструктуре серверов NATS вы можете использовать объект соединения для взаимодействия с NATS.

## Публикация в Core NATS

Вы можете напрямую [публиковать](sending/README.md) через соединение данные, адресованные subject (или публиковать заранее созданные сообщения с заголовками).

### Flush и Ping/Pong

Из-за кэширования, если вашему приложению критична низкая задержка, после публикации можно вызвать [flush](sending/caches.md).

Многие клиентские библиотеки используют взаимодействие [PING/PONG](connecting/pingpong.md), встроенное в протокол NATS, чтобы убедиться, что flush отправил все буферизованные сообщения на сервер. Когда приложение вызывает flush, большинство библиотек помещает PING в исходящую очередь сообщений и ждёт ответа PONG от сервера, прежде чем считать flush успешным.

Хотя клиент может использовать PING/PONG для flush, такие ping'и не учитываются в лимите [max outgoing pings](connecting/pingpong.md).

## Подписка в Core NATS

Процесс подписки заключается в том, что клиентская библиотека сообщает NATS, что приложению интересен конкретный subject. Когда приложение завершает работу с подпиской, оно отменяет её, чтобы сервер прекратил отправку сообщений.

Получение сообщений в NATS может зависеть от библиотеки: некоторые языки, такие как Go или Java, предоставляют синхронные и асинхронные API, другие могут поддерживать только один тип подписки. В целом приложения могут получать сообщения [асинхронно](receiving/async.md) или [синхронно](receiving/sync.md).

Можно подписываться сразу на несколько subject с помощью [wildcards](receiving/wildcards.md).

Клиент получит сообщение для каждой подходящей подписки, поэтому если у соединения несколько подписок с одинаковыми или пересекающимися subject (например, `foo` и `>`), одно и то же сообщение будет доставлено клиенту несколько раз.

### Подписка как часть группы очереди

Вы также можете подписаться [как часть распределённой *queue group*](receiving/queues.md). Все подписчики с одинаковым именем queue group формируют распределённую очередь. Серверы NATS автоматически распределяют сообщения, опубликованные на соответствующих subject, между участниками queue group.

Для одного subject может быть создано более одной queue group, каждая из них независима и распределяет свою копию сообщений между участниками этой группы.

### Медленные потребители

При подписке в Core NATS важно, чтобы ваше приложение успевало обрабатывать поток сообщений, публикуемых на subject. Иначе оно станет [медленным потребителем](events/slow.md).

## Отписка

Когда вы больше не хотите получать сообщения по конкретному subject, необходимо вызвать [unsubscribe](receiving/unsubscribing.md), либо можно [автоматически отписаться](receiving/unsub_after.md) после получения заданного числа сообщений.

## Отправка запросов к сервисам

NATS позволяет легко и прозрачно вызывать сервисы, не зная местоположение или количество серверов сервиса. Вызов [request](sending/request_reply.md) у соединения публикует сообщение на указанном subject, включает subject [reply-to](sending/replyto.md) для входящего ящика (inbox) и затем ждёт ответ.

## Обслуживание и ответы на запросы

Серверные приложения, обслуживающие запросы, должны подписаться на subject, на который публикуются запросы, обработать полученные сообщения и [ответить](receiving/reply.md) на subject, указанный в атрибуте [Reply-to](receiving/reply.md) запроса.

Как правило, нет причин не делать ваш сервис распределённым (то есть масштабируемым и отказоустойчивым). Это означает, что если нет специальных причин, приложения, обслуживающие запросы, должны [подписываться на subject запросов с одинаковым именем queue group](receiving/queues.md). На одном subject может быть более одной queue group (например, одна queue group распределяет обработку запросов между экземплярами сервиса, а другая — распределяет логирование или мониторинг запросов).

# Стриминг с JetStream

Некоторые приложения могут использовать дополнительные возможности [JetStream](../jetstream/develop_jetstream.md) (streams, KV Store, Object Store). Как вы используете объект соединения Core NATS для операций Core NATS, так и для JetStream операций используется [*JetStream context*](js/context.md). В контексте можно задавать, например, таймаут для всех операций. JS context лёгкие, поэтому их безопасно разделять между потоками, но для лучшей производительности можно иметь контекст на поток.

## Функции стриминга

Вы можете использовать [streams](../jetstream/model_deep_dive.md#stream-limits-retention-and-policy) для двух основных сценариев:
- Временное развязывание: возможность подписывающемуся приложению по запросу получить повтор сообщений, сохранённых в stream из прошлых (и, возможно, будущих) публикаций.
- Очереди: возможность экземплярам подписывающегося приложения получать, безопасно обрабатывать и удалять (то есть потреблять) из stream отдельные сообщения или пачки, эффективно используя stream как распределённую очередь работ.

## Определение streams

Прежде чем использовать stream для повторного воспроизведения или потребления сообщений, опубликованных на subject, его нужно определить. Атрибуты определения stream задают:
- что хранится (то есть какие subject отслеживает stream)
- как хранится (например, файловое или in-memory хранилище, количество реплик)
- как долго сообщения хранятся (например, в зависимости от лимитов, интереса или как очередь работ): политика retention

Streams могут быть (и часто бывают) заранее определены административно (например, с помощью NATS CLI). Приложение также может [управлять streams (и consumers) программно](js/streams.md).

## Публикация в streams

Любое сообщение, опубликованное на subject, отслеживаемом stream, сохраняется в stream. Если ваше приложение публикует сообщение через Core NATS publish (из объекта соединения) на subject stream, сообщение будет сохранено в stream; издатели Core NATS не знают и не заботятся о том, существует ли stream для этого subject.
Однако, если вы знаете, что для этого subject будет определён stream, вы получите более высокое качество обслуживания, [публикуя через publish вызов JetStream context](js/publish.md) (а не через publish вызов соединения). Это потому, что публикации JetStream получают подтверждение (или нет) от серверов NATS, когда сообщение успешно получено _и_ сохранено в stream (в то время как публикации Core NATS серверами не подтверждаются). Эта разница также объясняет наличие синхронных и асинхронных вариантов публикации JetStream.

## Consumers stream

Stream *consumers* — это способ, которым приложения получают сообщения из stream. По аналогии с концепциями баз данных, consumers можно рассматривать как «представления» (views) над stream:

- Consumers могут иметь *фильтр subject*, чтобы выбирать сообщения из stream по их именам subject.
- Consumers имеют *policy подтверждений* (ack policy), определяющую, должно ли приложение *подтверждать* получение и обработку сообщений, отправляемых consumer'ом (обратите внимание, что явные подтверждения _требуются_ для некоторых типов stream и consumer'ов). Также определяется, сколько ждать подтверждения и сколько раз consumer должен пытаться повторно доставить неподтверждённые сообщения.
- Consumers имеют [*policy доставки*](../jetstream/model_deep_dive.md#consumer-starting-position), определяющую, с какого места в stream начинать доставку сообщений.
- Consumers имеют *policy воспроизведения* (replay policy), определяющую скорость воспроизведения сообщений.

Consumers также имеют небольшое состояние на сервере NATS для хранения «курсоров» последовательных номеров сообщений. Для одного stream можно иметь столько consumers, сколько нужно.

Клиентские приложения либо создают *ephemeral* consumers, либо определяют/находят *durable* consumers. Приложения либо подписываются на push consumers (consumers с subject доставки и, опционально, именем queue group для subject доставки), либо получают по запросу (включая опциональный prefetch) из pull consumers (consumers без subject доставки и queue group, так как они не нужны, при этом предоставляют тот же функционал).

### Ephemeral consumers

[Ephemeral consumers](../jetstream/model_deep_dive.md#ephemeral-consumers) по своему назначению недолговечны и автоматически удаляются серверами NATS, когда экземпляр приложения, который их создал, завершает работу. Ephemeral consumers создаются по требованию отдельными экземплярами приложения и используются только этим экземпляром.

Обычно приложения используют ephemeral *ordered push consumers*, чтобы получать свою собственную копию сообщений, сохранённых в stream, когда нужно.

### Durable consumers

Durable consumers, как следует из названия, рассчитаны на «постоянную работу» и используются (разделяются) несколькими экземплярами клиентского приложения или приложениями, которые останавливаются и перезапускаются несколько раз и должны сохранять состояние от запуска к запуску.

Durable consumers можно администрировать с помощью NATS CLI или управлять ими программно самим приложением. Consumer создаётся как durable просто указанием durable имени при создании.

Обычно приложения используют *durable pull consumers* для распределения и горизонтального масштабирования обработки (или потребления) сообщений в stream.

### Подтверждения consumer

Некоторые типы consumers (например, pull consumers) требуют, чтобы приложение, получающее сообщения от consumer, *явно* [подтверждало](../jetstream/model_deep_dive.md#acknowledgement-models) получение и обработку этих сообщений. Приложение может вызвать одну из следующих функций подтверждения на сообщении, полученном от consumer:
- `ack()` — позитивное подтверждение получения и обработки сообщения
- `term()` — указание, что сообщение не может и никогда не сможет быть обработано и не должно быть отправлено снова. Используйте term, когда запрос некорректен.
- `nack()` — негативное подтверждение обработки, показывающее, что сообщение следует отправить снова. Используйте nack, когда запрос корректен, но вы не можете обработать его. Если невозможность обработки вызвана временным состоянием, следует временно закрыть подписку до восстановления возможности обработки.
- `inProgress()` — указание, что обработка сообщения продолжается и требуется больше времени (до того, как сообщение будет снова рассмотрено для доставки)

## Более высокие качества обслуживания

Помимо временного развязывания и очередей, JetStream обеспечивает более высокое качество обслуживания по сравнению с Core NATS. Определение stream на subject и использование consumers обеспечивает качество обслуживания *как минимум один раз*, то есть вы гарантированно получите сообщение (даже если ваше приложение было выключено в момент публикации), но есть сценарии с пограничными отказами, в которых возможны дублирование сообщения из-за двойной публикации или двойная обработка сообщения из-за потери подтверждения или падения после обработки, но до подтверждения. Вы можете включить и использовать [дедупликацию сообщений](../jetstream/model_deep_dive.md#message-deduplication) и двойные подтверждения, чтобы защититься от этих сценариев и получить качество обслуживания [ровно один раз](../jetstream/model_deep_dive.md#exactly-once-delivery).

## Key Value Store

Функциональность [Key Value Store](js/kv.md) реализована поверх JetStream, но предлагает другой интерфейс в виде ключей и значений, а не имен subject и сообщений. Вы можете использовать bucket для установки (включая compare-and-set), получения и удаления значения (массив байт, как payload сообщения), связанного с ключом (строка, как subject). Также можно «наблюдать» изменения bucket по мере их появления. И наконец, можно поддерживать историю значений, связанных с ключом, а также получать конкретную ревизию значения.

## Object Store

**ВНИМАНИЕ: Technology Preview**

Object Store похож на Key Value Store, но предназначен для использования, когда значения могут быть произвольно большого размера, в отличие от ограничения максимальным размером сообщения NATS, как в случае с Key Value Store.
