# Протокол клиента

## Протокол клиента

Сетевой протокол, используемый для обмена между сервером NATS и клиентами, это простой текстовый publish/subscribe-протокол. Клиенты подключаются к `nats-server` через обычный TCP/IP-сокет и используют небольшой набор протокольных команд, завершаемых переводом строки.

В отличие от традиционных систем обмена сообщениями с бинарным форматом и обязательным API, текстовый протокол NATS позволяет просто реализовывать клиентов на большом числе языков программирования и сценариев. Для практики см. [NATS Protocol Demo](../nats-protocol-demo.md), где можно поработать с протоколом через telnet.

Сервер NATS реализует [zero allocation byte parser](https://youtu.be/ylRKac5kSOk?t=10m46s), который работает быстро и эффективно.

## Соглашения протокола

**Управляющая строка с опциональным содержимым**: каждое взаимодействие клиента и сервера состоит из управляющей (протокольной) текстовой строки и, опционально, содержимого сообщения. Большинство команд не требует payload, он есть только у `PUB`, `MSG`, `HPUB` и `HMSG`.

**Разделители полей**: поля протокольных сообщений NATS разделяются пробелом ` ` или табуляцией `\t`. Несколько пробельных символов подряд считаются одним разделителем.

**Новые строки**: NATS использует `␍` + `␊` (`␍␊`, `0x0D0A`) для завершения протокольных сообщений. Эта последовательность также используется как граница payload в сообщениях `PUB`, `MSG`, `HPUB` и `HMSG`.

**Имена subject-ов**: имена subject-ов (включая reply subject) чувствительны к регистру, должны быть непустыми и не могут содержать встроенных пробелов. Разрешены UTF-8 символы, кроме пробела/табуляции и разделителей `.` и `>`. Subject можно структурировать токенами через точку (`.`), например:

`FOO`, `BAR`, `foo.bar`, `foo.BAR`, `FOO.BAR`, `FOO.BAR.BAZ` - валидные имена.

`FOO. BAR`, `foo. .bar`, `foo..bar` - невалидные имена.

Subject состоит из одного или более токенов. Токены разделяются `.` и могут содержать любые непробельные UTF-8 символы. Полный wildcard-токен `>` допустим только последним и совпадает со всеми последующими токенами. Wildcard-токен `*` совпадает с любым токеном в своей позиции. Wildcard-токены должны использоваться только как wildcard, а не как часть буквального токена.

**Кодировка символов**: имена subject-ов должны быть совместимы с UTF-8.

**Wildcard-ы**: NATS поддерживает wildcard в subject-подписках.

* Символ `*` совпадает с одним токеном на соответствующем уровне subject-а.
* Символ `>` (_full wildcard_) совпадает с одним или несколькими токенами в хвосте subject-а и должен быть последним токеном. Subject `foo.>` совпадёт с `foo.bar` и `foo.bar.baz.1`, но не с `foo`.
* Wildcard должен быть отдельным токеном (`foo.*.baz` и `foo.>` синтаксически валидны; `foo*.bar`, `f*o.b*r` и `foo>` - нет).

Например, wildcard-подписки `foo.*.quux` и `foo.>` обе совпадают с `foo.bar.quux`, но только `foo.>` совпадает с `foo.bar.baz`. С `>` также можно выразить интерес ко всем subject-ам в NATS: `sub > 1` (в пределах правил авторизации).

## Протокольные сообщения

Таблица ниже кратко описывает сообщения протокола NATS. Имена протокольных операций не чувствительны к регистру, то есть `SUB foo 1␍␊` и `sub foo 1␍␊` эквивалентны.

Нажмите на имя команды для подробного описания и синтаксиса:

| OP Name                 | Sent By | Description                                                                        |
|-------------------------|---------|------------------------------------------------------------------------------------|
| [`INFO`](./#info)       | Server  | Отправляется клиенту после начального TCP/IP-подключения                         |
| [`CONNECT`](./#connect) | Client  | Отправляется серверу с параметрами подключения                                    |
| [`PUB`](./#pub)         | Client  | Публикация сообщения в subject с опциональным reply subject                       |
| [`HPUB`](./#hpub)       | Client  | Публикация сообщения в subject с NATS-заголовками и опциональным reply subject   |
| [`SUB`](./#sub)         | Client  | Подписка на subject (или wildcard subject)                                        |
| [`UNSUB`](./#unsub)     | Client  | Отписка (или автоотписка) от subject                                              |
| [`MSG`](./#msg)         | Server  | Доставка payload сообщения подписчику                                              |
| [`HMSG`](./#hmsg)       | Server  | Доставка payload сообщения с NATS-заголовками                                     |
| [`PING`](./#pingpong)   | Both    | PING keep-alive сообщение                                                          |
| [`PONG`](./#pingpong)   | Both    | PONG keep-alive ответ                                                              |
| [`+OK`](./#okerr)       | Server  | Подтверждение корректного протокольного сообщения в `verbose`-режиме             |
| [`-ERR`](./#okerr)      | Server  | Протокольная ошибка; может привести к отключению клиента                          |

Ниже подробно описано каждое сообщение.

## INFO

### Описание

Клиент начинает с обычного TCP-соединения. Когда сервер принимает подключение клиента, он отправляет информацию о себе, конфигурации и требованиях безопасности, необходимых для успешной аутентификации и обмена сообщениями.

При использовании обновленного клиентского протокола (см. [`CONNECT`](./#connect) ниже) сообщения `INFO` могут приходить в любой момент. Это означает, что клиент соответствующего уровня протокола должен уметь обрабатывать `INFO` асинхронно.

### Синтаксис

`INFO {"option_name":option_value,...}␍␊`

Поддерживаемые JSON-поля:

| name              | description                                                                                                                                                            | type     | presence |
|-------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------|----------|
| `server_id`       | Уникальный идентификатор сервера NATS.                                                                                                                                | string   | always   |
| `server_name`     | Имя сервера NATS.                                                                                                                                                      | string   | always   |
| `version`         | Версия NATS.                                                                                                                                                           | string   | always   |
| `go`              | Версия Go, которой собран сервер NATS.                                                                                                                                | string   | always   |
| `host`            | IP-адрес запуска сервера NATS; по умолчанию `0.0.0.0`, может быть задан через `-client_advertise host:port`.                                                      | string   | always   |
| `port`            | Порт, на котором сервер NATS слушает подключения.                                                                                                                     | int      | always   |
| `headers`         | Поддерживает ли сервер заголовки.                                                                                                                                     | bool     | always   |
| `max_payload`     | Максимальный размер payload в байтах, принимаемый сервером от клиента.                                                                                               | int      | always   |
| `proto`           | Версия протокола сервера. Начиная с версии сервера 1.2.0 значение `1` означает поддержку функции `Echo`.                                                           | int      | always   |
| `client_id`       | Внутренний идентификатор клиента на сервере; можно использовать в мониторинге и корреляции логов ошибок.                                                            | uint64   | optional |
| `auth_required`   | Если `true`, клиенту следует аутентифицироваться при подключении.                                                                                                     | bool     | optional |
| `tls_required`    | Если `true`, клиент должен выполнить TLS/1.2 handshake. Ранее поле называлось `ssl_required`.                                                                       | bool     | optional |
| `tls_verify`      | Если `true`, клиент должен предоставить валидный сертификат в TLS handshake.                                                                                         | bool     | optional |
| `tls_available`   | Если `true`, клиент может предоставить валидный сертификат в TLS handshake.                                                                                          | bool     | optional |
| `connect_urls`    | Список URL серверов, к которым клиент может подключаться.                                                                                                             | [string] | optional |
| `ws_connect_urls` | Список URL серверов для websocket-клиента.                                                                                                                            | [string] | optional |
| `ldm`             | Если сервер поддерживает уведомления _Lame Duck Mode_ и уже перешел в lame duck, `ldm` будет `true`.                                                               | bool     | optional |
| `git_commit`      | Git-хеш, на котором был собран сервер NATS.                                                                                                                           | string   | optional |
| `jetstream`       | Поддерживает ли сервер JetStream.                                                                                                                                     | bool     | optional |
| `ip`              | IP сервера.                                                                                                                                                            | string   | optional |
| `client_ip`       | IP клиента.                                                                                                                                                            | string   | optional |
| `nonce`           | Nonce для использования в `CONNECT`.                                                                                                                                   | string   | optional |
| `cluster`         | Имя кластера.                                                                                                                                                          | string   | optional |
| `domain`          | Настроенный домен NATS на сервере.                                                                                                                                    | string   | optional |

#### connect_urls

Поле `connect_urls` содержит список URL, который сервер может отправлять при первом подключении клиента и при изменениях топологии кластера. Поле опционально и может отсутствовать в зависимости от конфигурации сервера и уровня клиентского протокола.

Когда кластер NATS расширяется, сервер отправляет клиенту сообщение `INFO` с обновленным `connect_urls`. Это упрощает облачные сценарии: клиент асинхронно узнает о новых серверах и может переподключиться к узлам, которые не были заданы изначально.

`connect_urls` выглядит как список строк с IP и портом, например: `"connect_urls":["10.0.0.184:4333","192.168.129.1:4333","192.168.192.1:4333"]`.

### Пример

Ниже пример строки подключения при telnet-соединении к `demo.nats.io`.

```bash
telnet demo.nats.io 4222
```
```
Trying 107.170.221.32...
Connected to demo.nats.io.
Escape character is '^]'.
INFO {"server_id":"Zk0GQ3JBSrg3oyxCRRlE09","version":"1.2.0","proto":1,"go":"go1.10.3","host":"0.0.0.0","port":4222,"max_payload":1048576,"client_id":2392}
```

## CONNECT

### Описание

Сообщение `CONNECT` - клиентская версия [`INFO`](./#info). После установки TCP/IP-соединения с сервером NATS и получения `INFO` клиент может отправить серверу `CONNECT`, чтобы передать сведения о текущем соединении и безопасности.

### Синтаксис

`CONNECT {"option_name":option_value,...}␍␊`

Поддерживаемые JSON-поля:

| name            | description                                                                                                                                                                                                                                                                       | type   | required                     |
|-----------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------|------------------------------|
| `verbose`       | Включает протокольные подтверждения [`+OK`](./#okerr).                                                                                                                                                                                                                           | bool   | true                         |
| `pedantic`      | Включает дополнительную строгую проверку формата, например корректности subject-ов.                                                                                                                                                                                             | bool   | true                         |
| `tls_required`  | Указывает, требуется ли клиенту SSL/TLS-соединение.                                                                                                                                                                                                                              | bool   | true                         |
| `auth_token`    | Токен авторизации клиента.                                                                                                                                                                                                                                                        | string | if `auth_required` is `true` |
| `user`          | Имя пользователя соединения.                                                                                                                                                                                                                                                      | string | if `auth_required` is `true` |
| `pass`          | Пароль соединения.                                                                                                                                                                                                                                                                 | string | if `auth_required` is `true` |
| `name`          | Имя клиента.                                                                                                                                                                                                                                                                      | string | false                        |
| `lang`          | Язык реализации клиента.                                                                                                                                                                                                                                                          | string | true                         |
| `version`       | Версия клиента.                                                                                                                                                                                                                                                                   | string | true                         |
| `protocol`      | `0` (или отсутствие поля) означает поддержку исходного протокола. `1` означает поддержку динамического обновления топологии кластера через асинхронные [`INFO`](./#info) с известными серверами для переподключения.                                                           | int    | false                        |
| `echo`          | Если `false`, сервер (версия 1.2.0+) не будет отправлять обратно в это соединение его собственные опубликованные сообщения. Используйте `false` только если сервер поддерживает это (то есть `proto` в `INFO` не меньше `1`).                                                  | bool   | false                        |
| `sig`           | Если сервер прислал `nonce` в `INFO`, клиент должен вернуть в этом поле подпись для этого `nonce`.                                                                                                                                                                               | string | if `nonce` received          |
| `jwt`           | JWT, определяющий права пользователя и аккаунт.                                                                                                                                                                                                                                   | string | false                        |
| `no_responders` | Включает [быстрые ответы в случаях, когда запрос отправлен в topic без ответчиков](/nats-concepts/core-nats/request-reply/reqreply.md#no-responders).                                                                                                                         | bool   | false                        |
| `headers`       | Поддерживает ли клиент заголовки.                                                                                                                                                                                                                                                 | bool   | false                        |
| `nkey`          | Публичный NKey клиента. Используется для проверки подписи (`sig`) по `nonce`, присланному в `INFO`.                                                                                                                                                                             | string | false                        |

### Пример

Пример строки из клиента Go по умолчанию:

```
CONNECT {"verbose":false,"pedantic":false,"tls_required":false,"name":"","lang":"go","version":"1.2.2","protocol":1}␍␊
```

Большинство клиентов по умолчанию ставит `verbose` в `false`. Это означает, что сервер не подтверждает каждое полученное в этом соединении сообщение через [`+OK`](./#okerr).

## PUB

### Описание

Сообщение `PUB` публикует payload в заданный subject, опционально указывая reply subject. Если reply subject задан, он будет доставлен подходящим подписчикам вместе с payload. Сам payload опционален: чтобы отправить пустое сообщение, установите размер payload в 0, но второй `CRLF` всё равно обязателен.

### Синтаксис

`PUB <subject> [reply-to] <#bytes>␍␊[payload]␍␊`

где:

| name       | description                                                                                   | type   | required |
|------------|-----------------------------------------------------------------------------------------------|--------|----------|
| `subject`  | Целевой subject для публикации.                                                               | string | true     |
| `reply-to` | Reply subject, который подписчики могут использовать для ответа издателю/инициатору запроса. | string | false    |
| `#bytes`   | Размер payload в байтах.                                                                      | int    | true     |
| `payload`  | Данные payload сообщения.                                                                     | string | false    |


### Пример

Публикация ASCII-строки `Hello NATS!` в subject `FOO`:

`PUB FOO 11␍␊Hello NATS!␍␊`

Публикация request-сообщения `Knock Knock` в subject `FRONT.DOOR` с reply subject `JOKE.22`:

`PUB FRONT.DOOR JOKE.22 11␍␊Knock Knock␍␊`

Публикация пустого сообщения в subject `NOTIFY`:

`PUB NOTIFY 0␍␊␍␊`

## HPUB

### Описание

Сообщение `HPUB` аналогично `PUB`, но расширяет payload, добавляя NATS-заголовки. Payload опционален: чтобы отправить только заголовки, установите общий размер сообщения равным размеру секции заголовков. Закрывающий `CR+LF` всё равно обязателен.

Заголовки NATS по структуре и семантике похожи на HTTP-заголовки: пары `name: value`, включая многозначные заголовки. Регистр символов в заголовках сохраняется между издателем и получателем. См. также [ADR-4 NATS Message Headers](https://github.com/nats-io/nats-architecture-and-design/blob/main/adr/ADR-4.md).

### Синтаксис

`HPUB <subject> [reply-to] <#header bytes> <#total bytes>␍␊[headers]␍␊␍␊[payload]␍␊`

где:

| name            | description                                                                                     | type   | required |
|-----------------|-------------------------------------------------------------------------------------------------|--------|----------|
| `subject`       | Целевой subject для публикации.                                                                  | string | true     |
| `reply-to`      | Reply subject для отправки ответа издателю/инициатору запроса.                                   | string | false    |
| `#header bytes` | Размер секции заголовков в байтах, включая разделитель `␍␊␍␊` перед payload.                     | int    | true     |
| `#total bytes`  | Общий размер секций заголовков и payload в байтах.                                              | int    | true     |
| `headers`       | Версия заголовков `NATS/1.0␍␊`, затем одна или более пар `name: value`, разделенных `␍␊`.       | string | false    |
| `payload`       | Данные payload сообщения.                                                                         | string | false    |

### Пример

Публикация ASCII-строки `Hello NATS!` в subject `FOO` с заголовком `Bar: Baz`:

`HPUB FOO 22 33␍␊NATS/1.0␍␊Bar: Baz␍␊␍␊Hello NATS!␍␊`

Публикация request-сообщения `Knock Knock` в `FRONT.DOOR` с reply subject `JOKE.22` и двумя заголовками:

`HPUB FRONT.DOOR JOKE.22 45 56␍␊NATS/1.0␍␊BREAKFAST: donut␍␊LUNCH: burger␍␊␍␊Knock Knock␍␊`

Публикация пустого сообщения в `NOTIFY` с заголовком `Bar: Baz`:

`HPUB NOTIFY 22 22␍␊NATS/1.0␍␊Bar: Baz␍␊␍␊␍␊`

Публикация сообщения в `MORNING.MENU` с заголовком `BREAKFAST` (два значения) и payload `Yum!`:

`HPUB MORNING.MENU 47 51␍␊NATS/1.0␍␊BREAKFAST: donut␍␊BREAKFAST: eggs␍␊␍␊Yum!␍␊`

## SUB

### Описание

`SUB` инициирует подписку на subject, опционально присоединяя клиента к распределенной queue group.

### Синтаксис

`SUB <subject> [queue group] <sid>␍␊`

где:

| name          | description                                                    | type   | required |
|---------------|----------------------------------------------------------------|--------|----------|
| `subject`     | Имя subject для подписки.                                      | string | true     |
| `queue group` | Если задано, подписчик присоединится к этой queue group.       | string | false    |
| `sid`         | Уникальный буквенно-цифровой ID подписки, генерируемый клиентом.| string | true     |

### Пример

Подписка на subject `FOO` с уникальным для соединения идентификатором подписки (`sid`) `1`:

`SUB FOO 1␍␊`

Чтобы подписать текущее соединение на subject `BAR` в составе распределенной queue group `G1` с `sid` `44`:

`SUB BAR G1 44␍␊`

## UNSUB

### Описание

`UNSUB` отменяет подписку соединения на указанный subject или настраивает автоотписку после получения заданного числа сообщений.

### Синтаксис

`UNSUB <sid> [max_msgs]␍␊`

где:

| name       | description                                                                | type   | required |
|------------|----------------------------------------------------------------------------|--------|----------|
| `sid`      | Уникальный буквенно-цифровой ID подписки, от которой нужно отписаться.     | string | true     |
| `max_msgs` | Число сообщений, которое нужно дождаться перед автоотпиской.                | int    | false    |

### Пример

Примеры ниже используют subject `FOO`, которому назначен `sid` `1`. Отписка от `FOO`:

`UNSUB 1␍␊`

Автоотписка от `FOO` после получения 5 сообщений:

`UNSUB 1 5␍␊`

## MSG

### Описание

Протокольное сообщение `MSG` используется для доставки прикладного сообщения клиенту.

### Синтаксис

`MSG <subject> <sid> [reply-to] <#bytes>␍␊[payload]␍␊`

где:

| name       | description                                                   | type   | presence |
|------------|---------------------------------------------------------------|--------|----------|
| `subject`  | Имя subject, на котором получено сообщение.                   | string | always   |
| `sid`      | Уникальный буквенно-цифровой ID подписки.                     | string | always   |
| `reply-to` | Subject, на котором издатель ожидает ответы.                  | string | optional |
| `#bytes`   | Размер payload в байтах.                                      | int    | always   |
| `payload`  | Данные payload сообщения.                                     | string | optional |

### Пример

Следующее сообщение доставляет прикладное сообщение из subject `FOO.BAR`:

`MSG FOO.BAR 9 11␍␊Hello World␍␊`

Чтобы доставить это же сообщение вместе с reply subject:

`MSG FOO.BAR 9 GREETING.34 11␍␊Hello World␍␊`

## HMSG

### Описание

Сообщение `HMSG` аналогично `MSG`, но расширяет payload заголовками. См. также [ADR-4 NATS Message Headers](https://github.com/nats-io/nats-architecture-and-design/blob/main/adr/ADR-4.md).

### Синтаксис

`HMSG <subject> <sid> [reply-to] <#header bytes> <#total bytes>␍␊[headers]␍␊␍␊[payload]␍␊`

где:

| name            | description                                                                                     | type   | presence |
|-----------------|-------------------------------------------------------------------------------------------------|--------|----------|
| `subject`       | Имя subject, на котором получено сообщение.                                                      | string | always   |
| `sid`           | Уникальный буквенно-цифровой ID подписки.                                                        | string | always   |
| `reply-to`      | Subject, на котором издатель ожидает ответы.                                                     | string | optional |
| `#header bytes` | Размер секции заголовков в байтах, включая разделитель `␍␊␍␊` перед payload.                     | int    | always   |
| `#total bytes`  | Общий размер секций заголовков и payload в байтах.                                               | int    | always   |
| `headers`       | Версия `NATS/1.0␍␊`, затем одна или более пар `name: value`, разделенных `␍␊`.                   | string | optional |
| `payload`       | Данные payload сообщения.                                                                          | string | optional |

### Пример

Следующее сообщение доставляет сообщение из `FOO.BAR` с заголовком:

`HMSG FOO.BAR 34 45␍␊NATS/1.0␍␊FoodGroup: vegetable␍␊␍␊Hello World␍␊`

Чтобы доставить то же сообщение с reply subject:

`HMSG FOO.BAR 9 BAZ.69 34 45␍␊NATS/1.0␍␊FoodGroup: vegetable␍␊␍␊Hello World␍␊`

## PING/PONG

### Описание

`PING` и `PONG` реализуют простой keep-alive между клиентом и сервером. После подключения клиента сервер NATS периодически отправляет `PING` с настраиваемым интервалом. Если клиент не отвечает `PONG` в установленный интервал, сервер закрывает соединение. Если соединение слишком долго остаётся неактивным, оно разрывается.

Если сервер присылает `PING`, клиент может ответить `PONG`, подтверждая, что соединение живо. Клиент также может отправить `PING` серверу и получить `PONG` в ответ. Интервал ping/pong настраивается.

Сервер использует обычный трафик как proxy-сигнал живости, поэтому клиент с постоянным потоком сообщений может не получать отдельные `PING` от сервера.

### Синтаксис

`PING␍␊`

`PONG␍␊`

### Пример

Пример ниже показывает, как демо-сервер пингует клиента и затем закрывает соединение.

```
telnet demo.nats.io 4222

Trying 107.170.221.32...
Connected to demo.nats.io.
Escape character is '^]'.
INFO {"server_id":"Zk0GQ3JBSrg3oyxCRRlE09","version":"1.2.0","proto":1,"go":"go1.10.3","host":"0.0.0.0","port":4222,"max_payload":1048576,"client_id":2392}
PING
PING
-ERR 'Stale Connection'
Connection closed by foreign host.
```

## +OK/ERR

### Описание

Если опция подключения `verbose` установлена в `true` (значение по умолчанию), сервер подтверждает каждое корректное протокольное сообщение клиента сообщением `+OK`. Большинство клиентов NATS отключает `verbose` (`false`) через [`CONNECT`](./#connect).

Сообщение `-ERR` используется сервером для передачи клиенту протокольной, авторизационной или другой runtime-ошибки соединения. Большинство таких ошибок приводит к закрытию соединения сервером.

Обработка таких ошибок обычно выполняется асинхронно.

### Синтаксис

`+OK␍␊`

`-ERR <error message>␍␊`

Часть протокольных ошибок приводит к закрытию соединения сервером. После получения таких ошибок соединение считается недействительным, и клиент должен освободить связанные ресурсы. К таким ошибкам относятся:

* `-ERR 'Unknown Protocol Operation'`: неизвестная протокольная операция
* `-ERR 'Attempted To Connect To Route Port'`: клиент попытался подключиться к route-порту вместо клиентского порта
* `-ERR 'Authorization Violation'`: клиент не прошел аутентификацию с учетными данными из [`CONNECT`](./#connect)
* `-ERR 'Authorization Timeout'`: клиент слишком долго аутентифицировался после установления соединения (по умолчанию 1 секунда)
* `-ERR 'Invalid Client Protocol'`: клиент указал неверную версию протокола в [`CONNECT`](./#connect)
* `-ERR 'Maximum Control Line Exceeded'`: длина subject назначения и reply subject превысила максимум `max_control_line` (по умолчанию 1024 байта)
* `-ERR 'Parser Error'`: не удалось распарсить протокольное сообщение клиента
* `-ERR 'Secure Connection - TLS Required'`: сервер требует TLS, но у клиента TLS не включен
* `-ERR 'Stale Connection'`: сервер слишком долго не получал сообщения от клиента, включая `PONG`
* `-ERR 'Maximum Connections Exceeded`': сервер превысил максимальное число соединений `max_connections` при создании нового подключения (по умолчанию 64k)
* `-ERR 'Slow Consumer'`: объем pending-данных для соединения достиг максимума (по умолчанию 10MB)
* `-ERR 'Maximum Payload Violation'`: клиент попытался опубликовать сообщение, payload которого превышает `max_payload`, настроенный на сервере. Это значение клиент получает в начальном [`INFO`](./#info), и должен корректно считать отправляемые байты для синхронной обработки ошибки.

Ниже перечислены протокольные ошибки, при которых соединение остается открытым. В этих случаях клиент не должен закрывать соединение.

* `-ERR 'Invalid Subject'`: клиент отправил некорректный subject (например, `sub foo. 90`)
* `-ERR 'Permissions Violation for Subscription to <subject>'`: пользователь из [`CONNECT`](./#connect) не имеет права подписываться на этот subject
* `-ERR 'Permissions Violation for Publish to <subject>'`: пользователь из [`CONNECT`](./#connect) не имеет права публиковать в этот subject
