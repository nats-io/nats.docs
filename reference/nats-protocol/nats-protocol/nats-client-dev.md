# Разработка клиента

## Руководство по разработке клиента NATS

Это руководство описывает ключевые аспекты разработки клиентов NATS:

* обработка `CONNECT`
* авторизация
* verbose-режим (acks)
* pedantic-режим
* интервал ping/pong
* парсинг протокола
* выбор стратегии парсинга
* хранение и диспетчеризация callback-подписок
* реализация request/response
* обработка ошибок, отключение и переподключение
* поддержка кластеров

Лучший способ быстро понять реализацию клиента - посмотреть на официальные клиенты команды Synadia. Обычно они полнофункциональны: если можете использовать их напрямую, это оптимально; если нужно писать собственный клиент, они все равно дают полезные инженерные ориентиры.

* [GoLang](https://github.com/nats-io/nats.go)
* [Java](https://github.com/nats-io/nats.java)
* [C# / .NET](https://github.com/nats-io/nats.net)
* [Rust](https://github.com/nats-io/nats.rs)
* [JavaScript](https://github.com/nats-io/nats.js)
* [Python](https://github.com/nats-io/nats.py)
* [C](https://github.com/nats-io/nats.c)

Больше ссылок и языков от сообщества - в [Developing with NATS](../../../using-nats/developing-with-nats/developer.md).

## Опции подключения клиента

Клиенты могут подключаться в аутентифицированном или неаутентифицированном режиме, а также в verbose-режиме, который включает подтверждения. Подробности см. в [документации протокола](./#connect).

## Авторизация клиента

По умолчанию клиент может подключаться к серверу без аутентификации. Сервер NATS можно настроить так, чтобы требовалась парольная аутентификация.

Например, через командную строку:

```shell
nats-server -DV -m 8222 -user foo -pass bar
```

Тогда клиент должен аутентифицироваться при подключении:

```shell
nats.Connect("nats://foo:bar@localhost:4222")
```

## Verbose-режим

Если включен `verbose` (через сообщение `CONNECT`), сервер NATS возвращает `+OK`, подтверждая получение корректного протокольного сообщения. Сервер сам по себе работает в verbose-режиме, но большинство клиентов отключает его (`false` в `CONNECT`) ради производительности.

## Pedantic-режим

Клиент также может поддерживать `pedantic`-режим. Он сообщает серверу, что требуется более строгая проверка формата протокольных сообщений.

## Интервал ping/pong

NATS использует автоочистку неактивных соединений. Когда клиент подключается, сервер ожидает, что клиент активен. Периодически сервер отправляет ping каждому подписчику и ждёт ответ. Если ответа нет в пределах настроенного таймаута, сервер отключает клиента.

## Парсинг протокола

NATS использует текстовый формат протокольных сообщений. Это делает реализацию клиентов простой для многих языков. Основной инженерный выбор - стратегия парсинга.

Сервер NATS реализует [zero allocation byte parser](https://youtu.be/ylRKac5kSOk?t=10m46s), который работает быстро и эффективно. На уровне wire сообщение NATS - это срез байтов. По сети оно передаётся как неизменяемая строка поверх TCP. Логика парсинга целиком на стороне клиента.

Структура сообщения NATS включает subject, опциональный reply и опциональный data (массив байтов). Тип `Msg` используется подписчиками и `PublishMsg()`.

```text
type Msg struct {
    Subject string
    Reply   string
    Data    []byte
    Sub     *Subscription
}
```

Издатель NATS публикует аргумент `data` на subject. Данные не модифицируются и должны корректно интерпретироваться на стороне получателя. Конкретная реализация парсинга зависит от языка.

## Выбор стратегии парсинга

Как правило, парсинг протокола в клиенте NATS - это строковые операции. Например, в Python строковые операции обычно быстрее regex. В Go и Java также чаще используют строковый парсинг. В Ruby, наоборот, regex обычно быстрее строковых операций, поэтому там используют regex.

Универсальной формулы нет: решение зависит от языка. Но стратегию парсинга нужно закладывать заранее при проектировании клиента.

## Хранение и диспетчеризация callback-подписок

При подписке на сервер необходимо хранить и вызывать callback-обработчики.

На стороне клиента обычно используется hash map, который сопоставляет subscription ID с подпиской и callback.

Ключ hash map - subscription ID. По этому ключу ищется callback. Когда клиент парсит сообщение, пришедшее с wire, он передаёт `subject`, `reply subject` и `payload` в callback, и тот выполняет обработку.

Итого: необходимо хранить отображение subscription ID -> callback. Callback находится внутри объекта подписки.

## Реализация request/response

Что использовать - pub/sub или req/rep - зависит от вашего сценария. Лучше пройти оба туториала и сравнить практические отличия.

## Обработка ошибок, отключение и переподключение

Ключевые аспекты обработки ошибок - корректная реакция на отключения клиента и реализация логики retry/reconnect.

## Поддержка кластеров

Клиент NATS уже имеет логику переподключения. Поэтому при реализации поддержки кластеров callback-обработчики reconnect нужно задавать заранее, а не менять динамически в рантайме. При запуске клиента эта информация уже должна быть определена.
