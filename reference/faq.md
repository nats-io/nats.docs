# Часто задаваемые вопросы (FAQ)

### Общие вопросы

* [Что такое NATS?](faq.md#что-такое-nats)
* [На каком языке написан NATS?](faq.md#на-каком-языке-написан-nats)
* [Кто поддерживает NATS?](faq.md#кто-поддерживает-nats)
* [Какие клиенты поддерживаются?](faq.md#какая-поддержка-клиентов-существует-для-nats)
* [Что означает аббревиатура NATS?](faq.md#что-означает-аббревиатура-nats)
* [Что такое JetStream и как он связан с NATS Streaming?](faq.md#jetstream-и-nats-streaming)

### Технические вопросы

* [В чем разница между Request() и Publish()?](faq.md#в-чем-разница-между-request-и-publish)
* [Могут ли несколько подписчиков получить один и тот же Request?](faq.md#могут-ли-несколько-подписчиков-получить-request)
* [Как мониторить кластер NATS?](faq.md#как-мониторить-кластер-nats)
* [Поддерживает ли NATS очереди и балансировку нагрузки?](faq.md#поддерживает-ли-nats-очереди-и-балансировку-нагрузки)
* [Можно ли получить список всех существующих subjects?](faq.md#можно-ли-получить-список-субъектов-в-кластере)
* [Поддерживает ли NATS wildcard subject-ов?](faq.md#поддерживает-ли-nats-subject-wildcards)
* [Какой тип consumer-а лучше использовать?](faq.md#какой-тип-stream-consumer-использовать)
* [Что означают 'verbose' и 'pedantic' при CONNECT?](faq.md#что-означают-verbose-и-pedantic-в-connect)
* [Гарантирует ли NATS порядок доставки сообщений?](faq.md#гарантирует-ли-nats-порядок)
* [Есть ли ограничение размера сообщений?](faq.md#есть-ли-ограничение-размера)
* [Есть ли лимит на число subjects?](faq.md#есть-ли-лимит-на-число-subjects)
* [Гарантирует ли NATS доставку сообщений?](faq.md#гарантирует-ли-nats-доставку)
* [Поддерживает ли NATS воспроизведение исторических данных?](faq.md#поддерживает-ли-nats-воспроизведение)
* [Как корректно завершить асинхронного подписчика?](faq.md#как-правильно-завершить-асинхронного-подписчика)
* [Как создавать subjects?](faq.md#как-создавать-subjects)
* [Сколько клиентов может одновременно подключиться?](faq.md#сколько-клиентов-может-подключиться)

## Общие вопросы

### Что такое NATS?

NATS — это открытая, лёгкая, высокопроизводительная облачная система обмена сообщениями. Она реализует масштабируемую и изящную модель publish-subscribe. Благодаря своей производительности NATS подходит как основа для современных надёжных распределённых систем.

NATS представлен двумя модулями в одном бинарнике `nats-server`:

* `Core NATS` — базовая функциональность и стандарты качества.
* [JetStream](../using-nats/jetstream/develop_jetstream.md) — встроенный, опционально включаемый слой персистентности, добавляющий стриминг, гарантии «как минимум один раз» и «ровно один раз», воспроизведение истории, развязанный контроль потока и key/value store.

NATS создал Дерек Коллисон, специалист с более чем 25-летним опытом проектирования pub-sub систем. Сейчас проект поддерживается широким Open Source-сообществом. Подробнее — на [GitHub](https://www.github.com/nats-io).

### На каком языке написан NATS?

Сервер `nats-server` написан на Go. Клиентские библиотеки доступны для множества языков — см. страницу [Developing with NATS](../using-nats/developing-with-nats/developer.md).

### Кто поддерживает NATS?

NATS поддерживается небольшой группой Maintainers в рамках процессa Governance и входит в [Cloud Native Computing Foundation (CNCF)](http://cncf.io). Инженеры Synadia совместно с сообществом поддерживают сервер, NATS Streaming и клиенты (Go, Ruby, Node.js, C, C#, Java и др.). Активное сообщество добавляет другие клиенты и коннекторы. Полный список доступен на странице [download](https://nats.io/download).

### Какая поддержка клиентов существует для NATS?

Последний список клиентов (официальных и сторонних) см. на [Developing with NATS](../using-nats/developing-with-nats/developer.md).

### Что означает аббревиатура NATS?

NATS расшифровывается как Neural Autonomic Transport System. Это платформа обмена сообщениями, работающая как нервная система.

### JetStream и NATS Streaming?

Начиная с версии 2.2 сервер рекомендует использовать [JetStream](../using-nats/jetstream/develop_jetstream.md) для персистентности и стриминга. [NATS Streaming (STAN)](https://github.com/nats-io/nats-streaming-server) объявлен deprecated.

## Технические вопросы

### В чем разница между Request() и Publish()?

`Publish()` отправляет сообщение на сервер с subject-ом, и сервер доставляет его всем подписчикам этого subject-а. При необходимости можно указать reply-subject, чтобы получатели ответили.

`Request()` упрощает создание INBOX-а (уникального subject-а) и отправку запроса с ожиданием ответа. Метод сам подписывается на INBOX, публикует сообщение с указанием reply и ждёт ответа или таймаут.

### Могут ли несколько подписчиков получить один Request?

Да. NATS — publish-subscribe система с локальными очередями. При публикации все подписчики получают сообщение. Если они входят в queue group, только один случайно выбранный участник группы получит сообщение, а остальные нет. NATS не сообщает отправителю, кто именно, зато гарантирует, что придёт ровно один ответ.

### Как мониторить кластер NATS?

Сервер может открывать HTTP(S) мониторинговый порт, например `https://demo.nats.io:8222/`. Также есть готовые инструменты:

* [Prometheus NATS Exporter](https://github.com/nats-io/prometheus-nats-exporter) — экспортер для Prometheus и Grafana.
* [nats-top](https://github.com/nats-io/nats-top) — top-подобный мониторинг.
* [natsboard](https://github.com/cmfatih/natsboard) — визуальный дашборд.
* [nats-mon](https://github.com/repejota/nats-mon) — ещё один мониторинг.

Подробнее — в разделе [Server Monitoring](../running-a-nats-service/configuration/monitoring.md).

### Поддерживает ли NATS очереди и балансировку нагрузки?

Да. NATS реализует распределённые очереди через queue groups подписчиков. Каждая группа получает по очереди сообщение, и между участниками происходит балансировка. Сообщения не сохраняются на диске, распределение строится на interest graph (подписках).

### Можно ли получить список существующих subjects?

Интерес-сетка (subjects и подписчики) обновляется в реальном времени. Это не статическая справка, а постоянно меняющийся граф. При желании можно опрашивать `/connz` и `/routez` мониторингового API, но напрямую выводить «доступные subject-ы» нельзя.

### Поддерживает ли NATS wildcard subject-ов?

Да. В NATS доступны два wildcard-символа:

* `*` — соответствует ровно одному токену (`foo.*` охватывает `foo.bar`, `foo.baz`).
* `>` — захватывает одну или несколько секций, и может быть только в конце (`foo.>` соответствует `foo.bar`, `foo.bar.baz`).

### Какой тип stream consumer-а выбрать?

Зависит от сценария:
* Для масштабирования обработки всех сообщений потока или для батчевых задач — используйте общий pull consumer (по нескольку клиентов можно параллельно вызывать `fetch`).
* Для индивидуального воспроизведения — ordered push consumer. Если нужен масштабируемый, низколатентный realtime, используйте durable push consumer с queue group.

### Что означают `verbose` и `pedantic` при CONNECT?

`verbose` включает подтверждения `+OK`/`-ERR` для каждой команды (по умолчанию включён). `pedantic` включает дополнительные проверки, например валидности subject-ов. Клиентские библиотеки обычно отключают `verbose` в INFO-хендшейке.

### Гарантирует ли NATS порядок доставки?

Да, для одного издателя сообщения доставляются в исходном порядке всем подписчикам. Между разными издателями гарантии порядка нет.

### Есть ли ограничение размера сообщений?

Да, в конфигурации (`max_payload`) задаёт максимальный размер сообщения. По умолчанию 1 МБ, можно увеличить до 64 МБ (рекомендуется ~8 МБ).

### Есть ли лимит на число subjects?

Начиная с `nats-server` v0.8.0 нет жёсткого ограничения на количество subjects.

### Гарантирует ли NATS доставку сообщений?

Core NATS обеспечивает «не более одного раза» (at-most-once). Сообщения целостны и упорядочены относительно одного издателя, но при проблемах соединения они могут быть потеряны. JetStream (с версии 2.2) добавляет персистентность и гарантии «как минимум один раз» и («ровно один раз» в пределах окна). Подробнее — в документации JetStream.

### Поддерживает ли NATS воспроизведение исторических данных?

Да, JetStream предлагает хранение и воспроизведение сообщений по времени или последовательности.

### Как корректно завершить асинхронного подписчика?

Вызовите `sub.Unsubscribe()` в Go (или аналог в других языках) — подписка завершится, а внутренние ресурсы очистятся. Это позволяет завершать обработчики без внезапного закрытия.

### Как создавать subjects?

Subjects создаются автоматически на основании интереса (подписок). Пока ни один клиент не подписан, subject не существует, и удаляется после отписки последнего клиента.

### Сколько клиентов может подключиться одновременно?

По умолчанию NATS поддерживает 65 536 соединений на сервер. Точная цифра зависит от ОС и настройки (например, ограничений FD/памяти). Большинство систем выдерживают тысячи соединений; при необходимости увеличьте лимиты ядра и TCP-буферов.
