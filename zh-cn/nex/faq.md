# Nex 常见问题

关于 NATS 执行引擎的常见问题

### 一般信息

* [什么是 Nex？](#什么是-Nex)
* [我在哪里可以找到 Nex？](#我在哪里可以找到-Nex)
* [谁维护 Nex？](#谁维护-nex)
* [Nex 是免费的吗？](#nex-是免费的吗)

### 运行工作负载

* [我可以运行哪些类型的工作负载？](#我可以运行哪些类型的工作负载)
* [什么是根文件系统？](#什么是根文件系统)

### 技术细节

* [什么是命名空间？](#什么是命名空间)
* [我的工作负载配置是否安全？](#我的工作负载配置是否安全)
* [run 和 devrun 有什么区别？](#run-和-devrun-有什么区别)
* [Nex 与 Kubernetes 相比如何？](#nex-与-kubernetes-相比如何)
* [我需要在 Firecracker 中运行 Nex 吗？](#我需要在-firecracker-中运行-nex-吗)

## 一般信息

### 什么是 Nex？
Nex 是一个开源、轻量级的执行引擎，可与 NATS 并行运行。通过运行 Nex *节点*，您可以构建一个通用资源池，在其中部署 服务和函数。服务和函数允许是 JavaScript、WebAssembly 甚至常规操作系统可执行二进制文件。

### 我在哪里可以找到 Nex？
Nex 的代码可以在相应的 [Synadia](https://github.com/synadia-io/nex) 仓库中找到。这是一个由 NATS 的创建者 Synadia 支持的开源项目。

### 谁维护 Nex？
Nex 代码的主要维护者是 Synadia 的员工，但我们也始终欢迎更多的维护者加入。

### Nex 是免费的吗？
嗯，Nex 仓库中的所有代码都是免费的，并使用 **Apache-2.0** 许可证授权给你。

## 运行工作负载

### 我可以运行哪些类型的工作负载？
Nex 支持两类工作负载：**服务**和**函数**。服务 是长期运行的，而函数 是短时运行的，并根据某些触发条件按需启动。

服务 可以是原生编译的二进制文件（启用 Firecracker 时为 64 位 **elf**），而 函数 可以是 WebAssembly 模块或导出的 JavaScript 函数。OCI 镜像支持即将推出。

### 什么是根文件系统？
默认情况下，Nex 使用 [Firecracker](https://firecracker-microvm.github.io/) 来启动小型、安全、快速且轻量的虚拟机。这些虚拟机各自运行一个代理，负责管理该虚拟机中的工作负载以及与 Nex 节点之间的通信。

根文件系统本质上是一个操作系统磁盘映像的快照，用于启动虚拟机时使用。它类似于 Docker 层，但效率更高。

## 技术细节

### 什么是命名空间？
命名空间是一种有关多租户的单元。所有工作负载都限定在某个命名空间内。如果您将 `echoservice` 工作负载部署到 `default` 命名空间，然后同样再将其部署到 `sample` 命名空间，Nex 不会将它们视为相同的。命名空间是逻辑分组，Nex 不强制实施严格的网络边界，也不强制规定您如何使用命名空间。

### 我的工作负载配置是否安全？
绝对安全！每个运行工作负载的请求都会发送到特定的 Nex 节点。该 Nex 节点有一个公钥 **Xkey**，用于加密发送到该节点的数据，例如环境变量和其他敏感数据。只有该节点才能解密发给它的数据。

此外，只有启动工作负载的实体才能终止该工作负载。

### run 和 devrun 有什么区别？
简而言之，`nex run` 适用于生产环境和实际部署，而 `nex devrun` 则适用于开发人员的迭代循环和测试环境。常规运行工作负载的请求必须包含以下所有内容：

* 一个颁发者 **nkey**，作为认证请求的实体；
* 一个发布者 **xkey**，用于加密数据源；
* 一个 URL，指示工作负载的位置，存储在对象存储中，格式为 `nats://{BUCKET}/{key}`；
* 一组传递给工作负载的环境变量；
* 一个固定且格式正确的工作负载 _名称_；
* 一个命名空间（逻辑分组），用于运行工作负载。

当您只是在本地机器上进行开发和测试时，手动提供所有这些信息会很麻烦，因此使用 `devrun` 时，您只需提供工作负载二进制文件（`.wasm`、`.js`、ELF 二进制）的路径和环境变量，`nex` CLI 将为您处理其余部分，包括自动将您的文件上传到对象存储。

### Nex 与 Kubernetes 相比如何？
Kubernetes 是一个分布式工作负载执行引擎，Nex 也是如此。但两者在此开始分道扬镳。Nex 能够提供高效且量身定制的用户体验，因为它对基于 NATS 的工作负载进行了优化和专门设计；而 Kubernetes 则被设计为高度通用，只要投入足够的时间或资金，几乎可以做任何事情。这种广泛的用例使 Kubernetes 在管理、部署和配置方面变得复杂。

大多数用户通过 Kubernetes 的 _声明式_ 层进行交互，该层需要大量的 YAML 配置来管理，而 Nex 是一个纯粹的命令式系统，可通过 CLI 和简单的 API 轻松管理。

### 我需要在 Firecracker 中运行 Nex 吗？
简单来说，**不需要**。Nex 节点进程负责生成包含 Nex 代理的 Firecracker VM。作为 Firecracker 进程的管理者，Nex 节点本身不能运行在 Firecracker VM 中。大部分复杂性应该对最终用户隐藏。
