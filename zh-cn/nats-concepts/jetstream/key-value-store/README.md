# 键值存储

JetStream 是 NATS 的持久化层，它不仅支持与“流”相关的更高服务质量和服务特性，还提供了一些消息系统中没有的功能。

其中一个功能是键值存储（Key/Value Store）功能，它允许客户端应用创建 `buckets`（存储桶），并将它们用作立即一致的（而非有延迟的最终一致）、持久化的 [关联数组](https://en.wikipedia.org/wiki/Associative_array)（或映射）。

注意，我们虽然保证在[单调写](https://jepsen.io/consistency/models/monotonic-writes)和[单调读](https://jepsen.io/consistency/models/monotonic-reads)方面的实时一致性，但目前不保证[写后再读一致性](https://jepsen.io/consistency/models/read-your-writes)，因为通过 _direct get_ 请求进行的读操作可能会被 追随者(followers) 或镜像(mirrors) 响应。可以通过向键值存储底层的流领导者发送 get 请求来获取更一致的结果。

* [操作指南](kv_walkthrough.md)
* [详细说明](../../../using-nats/developing-with-nats/js/kv.md)

## 管理键值存储
1. 创建一个存储桶，其对应于在底层存储中的一个流。按需定义 KV/流 的限制。
2. 使用以下操作。

## 映射风格的操作
您可以使用 键值存储桶 执行您期望从立即一致的键值存储中得到的典型操作：

* put：将一个值与一个键关联。
* get：检索与某个键相关联的值。
* delete：清除与某个键相关联的任何值。
* purge：清除所有键所关联的所有值。
* keys：获取所有键的副本（这些键可能有值或已关联操作）。

## 用于锁定和并发控制的原子操作
* create：仅当该键当前没有值时，才将值与该键关联（即比较是否为 null 并设置）。
* update：比较并设置（又称比较并交换），更新某个键的值。

## 限制大小、TTL 等
您可以为存储桶设置一些限制，例如：

* 存储桶的最大大小。
* 单个值的最大大小。
* TTL：存储器保留值的时间长短。

## 将键值存储视为消息流

最后，您甚至可以做一些通常无法在键值存储服务中完成的事：

* watch：监视某个键的变化，类似于订阅（发布/订阅意义上的）该键：观察者会实时接收到由于该键上的 put 或 delete 操作而推送过来的更新。
* watch all：监视存储桶中所有键上发生的所有变化。
* history：检索每个键随时间变化的值历史记录（以及删除操作）。默认情况下，存储桶的历史记录设置为 1，意味着只存储最新的值或操作。

## 注意事项

有效的键可以包含以下字符：`a-z`、`A-Z`、`0-9`、`_`、`-`、`.`、`=` 和 `/`，即它可以是由点分隔的标记列表（这意味着在监视存储桶时，您可以使用通配符匹配键的层次结构）。值可以是任意字节数组。