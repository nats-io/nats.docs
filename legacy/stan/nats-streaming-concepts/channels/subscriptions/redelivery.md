# Повторная доставка

Когда сервер отправляет сообщение потребителю, он ожидает получить от него ACK. Именно потребитель задает, сколько сервер должен ждать перед повторной отправкой всех неподтвержденных сообщений.

Когда сервер перезапускается и восстанавливает неподтвержденные сообщения для подписки, он сначала пытается повторно доставить их, а затем отправляет новые. Однако если на начальном этапе повторной доставки какие-то сообщения не дошли до клиента, сервер об этом не знает и начинает доставку новых сообщений.

_**Поэтому приложение может получать вперемешку повторно доставленные и новые сообщения. Обычно именно это и происходит вне сценария перезапуска сервера.**_

Для queue-подписок: если у участника есть неподтвержденные сообщения, то после истечения его `AckWait` \(интервал до попытки повторной доставки\) сообщения будут повторно доставлены любому участнику группы \(включая этого же участника\).

Если участник queue-группы покидает группу, его неподтвержденные сообщения перераспределяются между остальными участниками.

## Повторная доставка подтвержденных сообщений

Как описано выше, после отправки сообщения потребителю сервер запускает таймер длительностью `AckWait` этого потребителя. После истечения этого интервала при отсутствии `Ack` сообщение будет повторно доставлено.

Предположим, потребитель использует `AckWait` в 5 секунд и стандартный `MaxInflight` в 1024 сообщения. На момент запуска потребителя в канале доступно десять сообщений. Сервер доставляет их, и каждое будет отправлено повторно через 5 секунд, если ACK не придет.

Теперь представим, что обработчик сообщений в вашем приложении тратит 4 секунды на одно сообщение. Тогда видно, что хотя первое сообщение подтверждается до истечения `AckWait`, второе — уже нет: оно 4 секунды ждет в очереди библиотеки, пока обрабатывается первое, и еще 4 секунды обрабатывается само. Через 1 секунду после начала callback для второго сообщения сервер уже отправит его повторно. Поскольку остальные сообщения были доставлены почти одновременно, они тоже будут повторно доставлены. Даже если приложение подтвердит второе сообщение, это не мешает повторно доставленному экземпляру снова попасть в callback.

После обработки нескольких сообщений \(если каждое обрабатывается по 4 секунды\) легко увидеть, что некоторые сообщения будут попадать в callback много раз.

> Один из способов избежать такого поведения — задать `MaxInflight = 1` при создании подписки.

### Почему библиотека передает в callback уже подтвержденное сообщение?

Для не-queue подписок библиотеки могли бы реализовать что-то вроде ack-floor-механизма: он позволял бы определить, что сообщение уже подтверждено пользователем \(или auto-ack при возврате callback\), и подавлять его повторную доставку.

Однако для queue-подписок это невозможно \(и именно они, похоже, самые популярные\), потому что участник группы может получать sequence сообщений полностью не по порядку. Например, один участник может получить сообщения с 1 по 10, а другой в той же группе — 11, 13 и 15. Если первый участник завершится без подтверждения своих сообщений, сообщения 1-10 могут быть повторно доставлены второму участнику, который уже получил 11, 13 и 15. Поэтому концепция "floor" здесь не работает. Подход с map/time-детекцией мог бы помочь, но сейчас он не реализован ни в одной из поддерживаемых библиотек.

